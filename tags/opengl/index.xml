<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Opengl on けんごのお屋敷</title>
    <link>http://tkengo.github.io/tags/opengl/</link>
    <description>Recent content in Opengl on けんごのお屋敷</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 01 Feb 2015 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://tkengo.github.io/tags/opengl/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Hello World in OpenGL!</title>
      <link>http://tkengo.github.io/blog/2015/02/01/opengl-es-2-2d-knowledge-6/</link>
      <pubDate>Sun, 01 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2015/02/01/opengl-es-2-2d-knowledge-6/</guid>
      <description>OpenGL 基礎シリーズ の第 6 回です。
Hello World in OpenGL! いよいよこのシリーズもこれで最後。実際に動作するソースコードを紹介しながらこれまで得た知識と照らしあわせていきたい。記事の最初にも書いたとおりサンプルコードは Android になるけど、Android 固有の部分を除いて OpenGL の部分に関しては他のプラットフォームでも似たような API は提供されているので (若干仕様が異なる API もあるけど) これまでに蓄えられてきた基礎知識が活きていれば Android 以外でも「こんな風に書けばいいのかな」という想像が簡単にできると思う。
ということで早速コードを紹介しつつ解説を。
MainActivity.java public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); GameSurfaceView view = new GameSurfaceView(this); setContentView(view); } }  まずはアクティビティ。GameSurfaceView という独自のビューを生成してアクティビティに配置している。
GameSurfaceView.java public class GameSurfaceView extends GLSurfaceView { private static final int OPENGL_ES_VERSION = 2; public GameSurfaceView(Context context) { super(context); setEGLContextClientVersion(OPENGL_ES_VERSION); setRenderer(new GameRenderer()); setRenderMode(RENDERMODE_CONTINUOUSLY); } }  次に GameSurfaceView。Android で OpenGL を使った描画をするためには GLSurfaceView というビューを継承したカスタムビューを作る。そのカスタムビューの中で独自のレンダラーをセットすることで、そのレンダラーの中で実装された関数が呼び出され、OpenGL とのやり取りができるようになる。</description>
    </item>
    
    <item>
      <title>テクスチャマッピング</title>
      <link>http://tkengo.github.io/blog/2015/01/27/opengl-es-2-2d-knowledge-5/</link>
      <pubDate>Tue, 27 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2015/01/27/opengl-es-2-2d-knowledge-5/</guid>
      <description>OpenGL 基礎シリーズ の第 5 回です。
テクスチャマッピング 実は OpenGL では jpg や png といった画像の類をそのままフレームバッファに描画することはできないし、そもそも画像読み込み系の関数すら持ち合わせていない困ったチャンなのだ。この時点で画像描画に関しては詰んでそうだけど、そんなことはなくって (そんなことがあったら今頃 OpenGL なんて誰も使っていない) ちゃんと方法がある。それがテクスチャだ。
テクスチャという単語は聞いたことがあるかもしれないし「テクスチャを貼り付ける」だとか「画像を貼り付ける」だとかいうのは良く言われる。2D でゲームを作る場合はテクスチャを画像と同じ大きさの四角形のポリゴンに対して貼り付けることで画像を、例えばキャラクターの画像など画面上に表示させることができる。でも一体テクスチャとはどういうものなのか、どういう原理で画像をディスプレイに表示しているんだろうか。それがわかれば OpenGL で自由に画像を表示できるようになる。エフェクトをつけるのだって自由自在。
あなたは既にテクスチャのある世界への一歩を踏み出している。
テクスチャの準備 画像を表示するためにテクスチャを使うならば兎にも角にも、表示したい画像の用意が必要になる。ここでは Android Studio で新規プロジェクトを作った時に最初から同梱されているあの有名なドロイド君を使って説明を進めてみようと思う。いつもありがとう、ドロイド君。画像に困ったときは君だね☆
さて、ドロイド君に登場してもらったところで実際にこのドロイド君をテクスチャとして利用するためには、いろいろと前準備をやっとかないといけない。もっとも単純には GPU に対して以下のような要求を送ってやることになる。
 テクスチャが欲しいので新しく作ってちょうだい！ ありがとう。じゃぁこれからこのテクスチャに対していろいろ操作するからね フィルタリングの設定はこれでお願い 画像データをそっちに送るのでよろしく〜  それぞれの要求には専用の API が用意されているのでそれを呼び出すだけでいいので簡単なのだ。猫でもわかる OpenGL！
※マルチテクスチャを利用する場合はもう少し手順が増えることになるけど、それにもちゃんと専用の API が用意されている。とりあえず最低限これだけ把握できていれば問題はない。
テクスチャの生成 画像を読み込んでそれをテクスチャに割り当てるためには GPU に対して新しいテクスチャを生成するよう要求しないといけない。Android には glGenTextures というメソッドがあり、それを使って新しいテクスチャを生成する。テクスチャが生成されると整数型の数字 (1 とか 2 とか) を受け取り、それがテクスチャの ID となる。ちなみに Android では一気に複数のテクスチャの生成を要求することができる。
生成したテクスチャのバインド テクスチャを生成したらそのテクスチャをバインドする必要がある。テクスチャをバインドすることで、そのバインドされたテクスチャに対して、テクスチャパラメータの設定をしたり画像データを送信したりすることができるようになる。OpenGL のテクスチャ関連のメソッドのリファレンスを確認すればわかるけど、それらのメソッドの引数にはテクスチャ ID がない。つまりテクスチャに対する操作は、メソッドの引数でテクスチャ ID を指定するのではなく、OpenGL 側でテクスチャの状態を持っていて現在バインドされているテクスチャに対して行われるということになる。
テクスチャのバインドは glBindTexture というメソッドがあり、引数としてテクスチャ生成時に受け取ったテクスチャの ID を渡す。</description>
    </item>
    
    <item>
      <title>ラスタライザの画素生成と線形補間</title>
      <link>http://tkengo.github.io/blog/2015/01/17/opengl-es-2-2d-knowledge-4/</link>
      <pubDate>Sat, 17 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2015/01/17/opengl-es-2-2d-knowledge-4/</guid>
      <description>OpenGL 基礎シリーズ の第 4 回です。
ビューポート変換 ラスタライザの話をするまえにもひとつ変換についての話を。バーテックスシェーダによって長い長い座標系変換の旅 (いやテキストだと長いけど GPU での演算は一瞬で終わるからね。一瞬で) をしてきた頂点達にとって最後の変換過程が残っている。それがビューポート変換というやつだ。
「とうとう現れたか、ビューポート変換め！」 『 グヘヘヘよく来たな頂点ども。 』 「臆することはない、ヤツは 座標系変換四天王の中でも最弱 。」
ということで簡単です。
バーテックスシェーダで最終的に変換されたクリッピング座標系は xyz 座標がそれぞれ -1 〜 1 の範囲に正規化された座標系だったけど、それを実際にオブジェクトを描画するディスプレイのサイズの座標に変換する。その際、次のラスタライズの処理に繋げるために xy 成分だけ取り出して平面にしておく。これをウィンドウ座標系といって、左下が原点 (0, 0) になる。たとえば描画先のディスプレイのサイズが 800 x 600 だった場合はこんな感じ。
Android では以下のメソッドを呼び出すことでビューポート変換での幅や高さの設定ができる。
GLES20.glViewport(ディスプレイ左下のx座標, ディスプレイ左下のy座標, ディスプレイの幅, ディスプレイの高さ);  ところで残った z 座標はどこへ行くかというと、ポリゴンが重なっていた場合にその前後の位置関係を把握して重なりを制御するためにデプステストという工程がフラグメントシェーダの後にあるんだけど、そこで使われるために別途バッファに保存される。デプステストについては最初の目次に書いてないのでこのブログに出てくる予定はないけど、時間があればその仕組みを解説する記事をかいてみようかな。
ラスタライズ それでは本題のラスタライズの話。バーテックスシェーダとビューポート変換によって最終的な平面上での頂点の位置が計算されたことで最終的なポリゴンの形もここで確定された。次はこのポリゴン達がディスプレイ上の (正確にはフレームバッファー上の) どのピクセルに描画されるのかを求める必要がある。前にも書いたけど、ラスタライズは描画するピクセルつまり画素を生成することを言い、生成された画素のことをフラグメントと言う。ここではどのようにラスタライズが行われ、そしてそれらのピクセルがどのようにフラグメントシェーダに渡されるのかを詳しく見てみる。この辺の話は 2D を扱いたい場合でも 3D を扱いたい場合でも変わりはない。
ラスタライズには以下の 3 つのプロセスがある。
 ポリゴンの裏表面の判別 表面のポリゴンが覆っているピクセルのフラグメント生成 バーテックスシェーダから渡された値の線形補間  ポリゴンの裏表面の判別は頂点情報の話をした時にも書いたとおり、頂点インデックスを指定する順番によって変わる。裏表の判別が終わったら、次はフラグメントの生成に移る。ここでもしカリングが有効になっていれば裏面を向いたポリゴンは無視され、表面を向いているポリゴンが覆っているフレームバッファー上のフラグメントだけが生成される。カリングが無効になっていれば裏面ポリゴンも同様に処理される。そして最後にバーテックスシェーダから渡ってきた値 (たとえば頂点座標や法線情報、色情報、など) を生成されたフラグメント毎に線形補間して、フラグメントと一緒にフラグメントシェーダに渡してあげるといった流れになる。
フラグメント生成方法 OpenGL においてフレームバッファのある特定のピクセルのフラグメントが生成されるかどうかは、そのピクセルの中心がポリゴンの内側に位置しているかどうかによって決まる。以下の図は、各矩形が画面上の 1 ピクセルを表しており、その中にある赤い点がそのピクセルの中心点、そして赤い枠線がポリゴンの形になっている。中心点である赤い点が赤枠の内側にあるピクセルについては紫色で塗りつぶされており、これがラスタライズ処理によって生成されるフラグメントになる。そしてそれら 1 つ 1 つがすべてフラグメントシェーダに渡される。</description>
    </item>
    
    <item>
      <title>バーテックスシェーダによる座標系変換</title>
      <link>http://tkengo.github.io/blog/2015/01/10/opengl-es-2-2d-knowledge-3/</link>
      <pubDate>Sat, 10 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2015/01/10/opengl-es-2-2d-knowledge-3/</guid>
      <description>OpenGL 基礎シリーズの第 3 回です。
座標変換 プリミティブの描画には頂点座標が必要なのはわかった。だって、座標情報がないとそもそもどこに描画していいのかがわからないんだから。でもよく考えてみて欲しい、この座標情報って どの座標系における座標 なんだろう？それって最初に出てきた右手座標系とかいう座標系じゃないの？うーん、そうなんだけどここで話したいのはそういうことじゃない。それじゃディスプレイ上の座標に配置してるに決まってるよ！いやいやそんなことはない。私達は今、OpenGL 上で 3D 空間を扱っている。でも現実のディスプレイは 2D の平面。はい、これらはそもそも次元が違う。
最初にバーテックスシェーダの概要を書いた時に座標系の変換過程を図に示したのを思い出してみると、3D 空間を扱うためには少なくとも 4 つの座標系があった。最初に頂点座標を配置した座標系から最終的にはクリッピング座標系という座標系に変換していく必要があり、それこそがバーテックスシェーダの役割である。そして前回の記事で頂点座標を定義した時、その (x, y, z) で表される頂点座標は、実はローカル座標系における座標を指定していたのだ！ドヤァー
突然ドヤァーされても意味わからないと思うので詳細を見てみよう。
変換行列 では実際バーテックスシェーダで座標系の変換をするっていっても、それってどうやればいいのか。答えは行列です。行列というと高校数学程度の知識が必要になりそうだけど、行列の生成や演算など面倒なことは全て CPU や GPU がやってくれる。私達に必要なのは、どういう変換行列の種類があって、それをどのように組み合わせて利用するのか、ということだけなので「自分理系じゃなかったんだけど&amp;hellip;」という人でも心配はない。便利な世の中〜。
とはいえ、実際にどういうものかぐらいは頭に置いておいたほうがイメージしやすいので、絵に書いてみると行列ってこういうもの。いろいろ難しそうな表現があるけど、わからないならわからないで深く理解しなくても大丈夫な領域ではあるので不安にならずに先に進んで大丈夫だと思う。もし知りたければ適当にググれば解説サイトはいっぱい出てくる。
※頂点座標は (x, y, z) の 3 次元だったけど図の青枠で囲ってある頂点座標は 4 つになっている。最後の 1 ってなんだろう？これは頂点座標と変換行列の演算を単純にするために導入される 同次座標系 という新しい概念になるのだけど、この話を詳しくしだすと OpenGL から飛び出してしまうのでここでは割愛する。最後の 1 はよくある おまじない だ。。 。
では、前提知識をつけたところで実際にどういう風に座標系が変換されていくのかを見ていく。長い長い座標系変換への旅へ出発。
ワールド座標変換 まずはワールド座標変換。ジョジョじゃないよ。
 Picture by Hay Kranen / CC-BY
ポリゴンが組み合わさって何かしらの形を作っているものは「モデル」と呼ばれ、通常は大量のポリゴンを組み合わせて「人のモデル」とか「木のモデル」とか複雑なものが定義される。ここに表示しているのは ユタ・ティーポット と言って、これもモデルの 1 つで CG の分野では有名なモデル。こういったモデルはそのモデル専用のローカル座標を持っており、通常は頂点座標はこのローカル座標系の座標を表している。
そしてワールド座標変換とは、そういったローカル座標で定義されている各モデルを OpenGL 唯一の世界の座標に配置していく作業のことを言う。以下の図では立方体のモデル、三角柱のモデル、四角形のモデル、をそれぞれローカル座標系からワールド座標系へ変換している。こうしてみるとまるで OpenGL の世界の神様になったみたい。ワールド座標変換に使われる行列は</description>
    </item>
    
    <item>
      <title>頂点情報とプリミティブ</title>
      <link>http://tkengo.github.io/blog/2015/01/03/opengl-es-2-2d-knowledge-2/</link>
      <pubDate>Sat, 03 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2015/01/03/opengl-es-2-2d-knowledge-2/</guid>
      <description>OpenGL 基礎シリーズの第 2 回です。
OpenGL の座標系 まず頂点の話をする前に前提として知っておかなければならない座標系の話がある。私達が 3D の世界を扱う時は 右手座標系 と 左手座標系 という 2 つの座標系が存在する。それぞれの違いは z 軸の向き。
 右手座標系は z 軸の手前の方がプラス、z 軸の奥のほうがマイナス 左手座標系は z 軸の手前の方がマイナス、z 軸の奥のほうがプラス  3D の座標を扱う時はこの座標系のどちらかを採用しており、我らが OpenGL ではポリゴンを配置する時の座標系は右手座標系を使う。この右手座標系は数学の世界で使われている座標系で OpenGL がこれを採用したのはそれが理由と言われている。(※ちなみにご存知 Windows の DirectX 3D は標準では左手座標系を採用している)
2D を扱うにあたって遠近感を出すために z 軸を意識することはあんまりないけど、描画する要素の重なりを制御するために使うことはよくある。ゲームなどで画像を重ねて描画するにあたっては z 軸の奥の方がプラスになってる方がわかりやすく、右手座標系のように z 軸の手前の方がプラスになっているのは違和感がある人が多いかもしれないけど、自分の感覚と違ってもそこだけは間違えないようにしないと、背景の方がキャラクターより前にきてしまって、あれ？なんでキャラクターいないの？という風に思った通りの描画が出来なくなってしまうので要注意。
※ちなみになんで右手と左手というんだろうか？それは、親指の先を x 軸プラス方向、人差し指の先を y 軸プラス方向、中指の先を z 軸プラス方向と思って、実際の座標系の軸を手を使って形作ってみるとわかる。右手でそれをすると中指が自分の方向を向いて、左手でそれをすると中指が向こう側を向くはずだ。こういう単純でどうでもいいことでも、理由がわかって納得できると面白いですよね？
プリミティブ もう何度も言ってる気がするけど OpenGL では 3D の頂点情報 (x, y, z) を定義して、それを GPU に転送することで描画を行う。それによって描画されるものを プリミティブ と言って、OpenGL の世界で描画できる最小単位のことを言う。また新しい言葉が出てきた！ってひるまないひるまない。ただ単に言葉の定義だけ。で、プリミティブには以下の 3 種類がある。</description>
    </item>
    
    <item>
      <title>OpenGL が世界を描画する仕組み</title>
      <link>http://tkengo.github.io/blog/2014/12/27/opengl-es-2-2d-knowledge-1/</link>
      <pubDate>Sat, 27 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2014/12/27/opengl-es-2-2d-knowledge-1/</guid>
      <description>OpenGL 基礎シリーズの第 1 回です。
ビューイングパイプライン OpenGL が世界を描画するっていうタイトルだけでワクワクするなら、あなたはもう OpenGL の、いや、このブログの虜です。というのはおいといて、OpenGL で描画すると一言で言ってもその描画フローの中には大量の計算処理が含まれおり、そのフローをひと通り全て通り超えてこそ初めて画面に何か描画される。いわゆるパイプラインと呼ばれる処理の流れがあり、それはおおまかには以下のようになっている。細かくは他にもやってることはあるし厳密には実際と異なる部分もあるけど、これくらい抑えておけば基本はわかると思う。
ちなみに赤い部分は自分でプログラミングする必要がある。青い部分は設定値さえこちらから与えてやれば後は OpenGL が内部でよろしくやってくれる。
 ふー、ただ単に 1 枚の画像を描画するだけでもこれだけのフローがあって、そして突然わけもわからない単語が大量に出てくるもんだからブラウザを「そっと閉じる」人がいるかもしれないけど、まあ正しい反応かもしれない。そういう人達は素直に Cocos2d-x とか Unity とかでゲームを作るほうが幸せを感じられると思う。Cocos2d-x や Unity などの便利ツールは実は中でこんなことをやってるのだ。恩恵は計り知れない。ありがとう Cocos2d-x！ありがとう Unity！
さて、フローの各部分の詳細は別途記事にするとして大事な部分だけの簡単な概要だけをまずはどうぞ。
アプリ側でデータの準備 OpenGL では、どこに何を描画するかは頂点座標によって決まるので、頂点座標は必須で準備する必要がある。そして、描画する物体に対して移動・回転・拡大・縮小などの操作を加える場合には変換行列も必要になる。さらに、画像を表示したい場合はテクスチャの ID と UV 座標も必要になる。私達開発者は、こういった各種データをアプリケーション側で準備して、OpenGL が提供している API を介してデータを GPU に転送する。
いやしかし、頂点座標とか変換行列とか UV 座標とかわけのわからない単語がまた出てきて、突然のウルトラヴァイオレット！イミフ！！！ですが、でも大丈夫！ちゃんと別の記事で詳しく触れていくので。ちなみに UV はウルトラヴァイオレットじゃないよ。
シェーダ そしてまたすぐにわけのわからないシェーダとかいう単語が出てくる。シェーダって何だろう？Wikipedia によると
シェーダ（英: shader）とは、3次元コンピュータグラフィックスにおいて、シェーディング（陰影処理）を行うコンピュータプログラムのこと。「shade」とは「次第に変化させる」「陰影・グラデーションを付ける」という意味で、「shader」は頂点色やピクセル色などを次々に変化させるもの（より具体的に、狭義の意味で言えば関数）を意味する。 「はいはい、イミフイミフ」
いつも思うけど Wikipedia ってわざと難しく書いてない？さて、まず 2D だったら x 座標と y 座標を指定して描画するメソッドを呼び出せば簡単に画像でも線でも表示できた。できたんだけど、じゃぁ 3D はどうかっていうとそう簡単にはいかなくって、別途 3D 空間を描画するためのプログラムが必要になってくる。その描画するプログラムのことをシェーダと言って、シェーダにはいくつか種類があるんだけどとにかく OpenGL の場合、このシェーダプログラムがないといくら描画メソッドを呼び出しても画面には何も表示されない。
さて、そしてここから重要。OpenGL ES 1.x の頃は OpenGL に組み込みのシェーダが存在しており固定機能パイプラインとかって呼ばれてたけど、それに対して OpenGL ES 2.</description>
    </item>
    
  </channel>
</rss>