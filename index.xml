<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>けんごのお屋敷</title>
    <link>http://tkengo.github.io/</link>
    <description>Recent content on けんごのお屋敷</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sat, 30 Dec 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://tkengo.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>2017 年の振り返り</title>
      <link>http://tkengo.github.io/blog/2017/12/30/reviewing-2017/</link>
      <pubDate>Sat, 30 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2017/12/30/reviewing-2017/</guid>
      <description>2017 年は自分にとってキャリアが大きく動いた年だった。
1 年を振り返る良い機会だし、ちょっと頭の中で考えていることをきちんと言葉にしてみようと思う。それってとても難しいことだから普段ほとんどすることはないけど、思考を言語化することは自分を見つめ直す良い機会になるはず。
エンジニアとしての生き方 プログラミングに初めて触れたのは遡ればもう高校入学時の夏。プログラミングってなんでこんなに楽しくて、こんなにも興味をそそるもので、僕を感動させてくれるんだろう、とすぐにプログラミングの虜になり、将来は絶対エンジニアになると誓っていた。それから約 15 年間、よくもまあ飽きもせず仕事でも趣味でもプログラミングを続けているものだと自分でも関心するけど、エンジニアってそういう生き物なのだ（ですよね？）。&amp;rdquo;楽しい&amp;rdquo; が僕にとっての行動原理だったりする。&amp;rdquo;生きるため&amp;rdquo; という考えの元では少しも長く続いていなかったろう。プログラミングが僕自身を輝かせ、道を作ってくれた。
そういう意味では、好きなことを仕事にすれば幸せになれるというのは誰もが考えるところだとは思うけど、そもそも好きなことを仕事にするのはかなり難しい。100% 好きなことだけをして働いて生きていくのは到底無理だし、好きなだけではどうにもならない。覚悟が必要だ。自分の働きによって、どれだけ世の中に貢献できるのか、いや世の中なんて大層なものではなくてもいいけれど、どれだけ周囲に貢献できるのか、その価値と常に向き合っていく必要がある。しかし、自分の価値の話をし始めると、どうしても自分以外にも目がいってしまう。特に僕達の業界では、その年齢でどこでいつのまにそれ程の知識を得たのか、時間の進み方が僕らとはちょっと違うのでは？と疑問を抱くほどの凄腕スターエンジニアがうようよいる。そんな人達には到底かなわないので、じゃあ自分なんて&amp;hellip;と落ちてしまうこともある。
この辺のコントロールは本当に難しい。変化が速く激しいこの業界の中で自分の価値を見出し続けることは大変だし、人間なので落ちる時は落ちる。それを乗り越えられた時に、&amp;rdquo;楽しい&amp;rdquo; と &amp;ldquo;生きる&amp;rdquo; が繋がっていくのだと思う。要するに覚悟ってそういうことだ。自分を信じること。難しい問題も乗り越えられるように、いつでも自分を信じ続けること。
少し僕の話をすると、過去に プログラマのための数学勉強会@福岡 を主催していた。僕は数学科卒業でも数学に関して秀でているわけでもないので プログラマと数学 という記事で「数学ができないなりの楽しさ」と題して悩みを書き殴っていたけど、当時は数学とプログラミングの &amp;ldquo;楽しい&amp;rdquo; を原動力に行動していた。加えて今年は幸運にも書籍の執筆もさせてもらって、その時の心境も 「やさしく学ぶ 機械学習を理解するための数学のきほん」を執筆しました という記事にまとめおり、そこからもやはり悩みつつも、信じて行動し続けていたことがうかがえる。
これらは会社外での外向けの活動の話だけど、会社内での仕事の話だってそう変わらない。楽しいを原動力に、自分を信じてキャリアを積み上げていく。それが血となり肉となり、自分自身の価値となっていく。そうやって作っていった経験は誰にも真似出来ない自分だけの価値になっていく。
冒頭にも書いたけど、2017 年は自分にとって大きくキャリアが動いた節目の年だった。元来は Web や Android アプリケーションのエンジニアだった自分が、難しそうだったけど昔から好きだった機械学習やデータ分析を専門とした組織の立ち上げメンバーとして今年の頭から稼働してきた。それは、自分がそういった領域のエンジニアとしての価値を組織に対して提供できることを示してこれたからだと信じている。そして 2018 年からは、いわゆるマネージャーとしてのロールで組織にコミットしてく必要があり、いままでのように技術が好きなだけでは通用しない、組織の成長を俯瞰して見ていかなければならない。
だけど、自分のエンジニアとしての人生がそこで終わるわけではない。組織の中で与えられた役割は全うするべきだし、その役割の中で楽しいことはきっと見つけられる。それは好きなことを仕事にするってこととはちょっと違うかもしれないけど、これまで書いてきたエンジニアとして生きるための行動原理があったからこそいまの環境があると考えると、大きく外れた道ではなかったんだろうなと思うし、やっぱり好きだしそれを終わらせたくはない。個人的にプレイングマネージャーはあまり良くないと思うので、コードでコミットする時間は徐々に減っていくだろうけれど、プライベート含めゼロにはしたくないし、知識やスキルアップに関しては貪欲に求めていくように努力したい。
生き方や働き方、考え方なんて十人十色だし、これが正解という話はない。ただ、自分の中で信じることができる正解を持つことが、大事なんじゃないかな、って思う。
◎◎◎
振り返り まとまりのない感じになったんで、2017 年の印象的な出来事を軽く振り返ってみます。
データ分析組織 いまの勤め先で新しくデータ分析専門の組織が立ち上がり、初期メンバーとして稼働しました。立ち上げ自体は昨年ですが、実稼働し始めたのはだいたい今年頭からです。
[エンジニア対談]LINE Fukuokaのデータ分析・機械学習エンジニアとして取り組んでいきたいこととは？
もちろん私自身が立ち上げたわけではありませんが、以前から福岡にもそういう組織があるといいのでは、と声を上げていたのは事実でした。データ分析専門とはいいつつも、いわゆるデータサイエンティストと呼ばれる分析屋だけではなく、データ分析のためのインフラを管理したり機械学習によるテキスト分類など割りとエンジニアリング寄りなタスクもこなす集団になっていると思います。
英語環境 2017 年は特に英語を使う機会がとにかく多い一年でした。いまの会社はとにかくグローバル感が半端ないです。
【社員インタビュー】技術好奇心×カルチャー 開発室 室長が語るLINE Fukuokaの開発組織
この記事で室長が言っているようにいまの開発室は半数以上が外国籍社員です。これはデータ分析のチームも例外ではなく、そうなると必然的に英語によるコミュニケーションも増えてきます。もともと英語は嫌いな教科ではなかったけど、Reading / Writing だけじゃなくてまさか Listening / Speaking まで出来るようになるとは思ってもいない成長でした。(とはいえまだまだ Broken な英語ではあるので、もっと慣れが必要)
書籍執筆 幸運なことにマイナビ出版から書籍を出版させていただきました。
やさしく学ぶ 機械学習を理解するための数学のきほん
書籍の内容や出版の経緯などは この記事 にまとめている。おかげさまで何度か重版され、身近なエンジニア数人も買ってくれていて嬉しい限り。</description>
    </item>
    
    <item>
      <title>「やさしく学ぶ 機械学習を理解するための数学のきほん」を執筆しました</title>
      <link>http://tkengo.github.io/blog/2017/09/06/ml-math/</link>
      <pubDate>Wed, 06 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2017/09/06/ml-math/</guid>
      <description>私が執筆した書籍 やさしく学ぶ 機械学習を理解するための数学のきほん がマイナビ出版から Amazon で 2017/9/20 より発売されます。Amazon 上では既に予約可能になっていますので、興味のある方は是非とも手に取ってみてください。
  本書は、以前よりこのブログ内で公開していた「やる夫で学ぶ機械学習シリーズ」というシリーズ物の記事をベースとして、加筆・修正を加えたものになります。ブログの記事がベースになってはいますが、追加で書いた分の方が多く、お金を出して買ってもらえるクオリティにするために、より丁寧な説明を心がけて書きました。元記事は「やる夫」と「やらない夫」というキャラクターを登場人物として、機械学習の基礎を面白おかしく丁寧に解説していくものでしたが、書籍化するに当たって「やる夫」と「やらない夫」をそのまま使うわけにもいかなかったので、プログラマの「アヤノ」とその友達で機械学習に詳しい「ミオ」というキャラクターを新しく作って、彼女らの会話を通して一緒に勉強していく形を取っています。この本は以下のような構成になっていて、Chapter 1 〜 5 が本編で、Appendix で必要な数学知識の補足をしています。
 Chapter 1 - ふたりの旅の始まり Chapter 2 - 回帰について学ぼう Chapter 3 - 分類について学ぼう Chapter 4 - 評価してみよう Chapter 5 - 実装してみよう Appendix (本編に入り切らなかった数学知識の解説)  会話形式なので、全体的な文量もそこまで多くなくスラスラ読んでいけると思います。ただし、本書は機械学習の数学に関する入門書という位置付けなので、プログラミング自体の入門解説だったり、いろいろなアルゴリズムの紹介だったりは、内容にありません。Chapter 2 及び Chapter 3 あたりが、いま公開されているブログ記事ベースになっていますので、いきなり本を買うのが嫌な方や試し読みをしてみたい方などは、まず やる夫で学ぶ機械学習シリーズ を読んでみると、感覚をつかんでいただけるのではないかなと思います。また、マイナビ出版の Facebook には 本書のサンプルページ が掲載されていますので、そちらを見ても雰囲気はつかんでいただけるかなと思います。
執筆にかけた想い 書籍の宣伝はこの辺にして、ここからは個人的な想いを書いたポエムですので、ご了承ください。
- 数学や機械学習を通じて、気軽に話したりお互いに刺激し合える仲間が欲しい -
始まりは、ただ、それだけでした。
私がいわゆる機械学習と言われる領域に足を踏み入れた頃は、いまほど界隈は賑わっていませんでした。元々は大学時代からコンピュータービジョンや 3D に興味があり、それらに関するアルゴリズムや実装を探しているうちに機械学習に興味をもって勉強し始めましたが、もちろん当時は参考にできる Web サイトも書籍も、今よりも少ない状態です。仕事として機械学習をやっているわけでもなく、手取り足取り教えてくれるような詳しい人や、機械学習に興味を持っていそうな人は周りにはおらず、毎日ひとりでアテもなく先の見えない道を進むばかりだったのを覚えています。一人きりで何かを続けていくことほど、モチベーションが長続きしないことはありません。
そんな状況でしたのでちょっとだけ勉強には苦労していたのですが、学生時代から数学が好きだったこともあり (得意かどうかは置いといて) 数学に対する抵抗はまったくありませんでした。むしろ数学をやっている時間は一人でも楽しくて、没頭することができました。そうして勉強しながらしばらく時が経ち、世の中が機械学習やディープラーニングで盛り上がりを見せ始めたのをきっかけに、自分のブログでもぽつぽつと機械学習に関する情報を発信するようになっていきます。また、数学好きが高じて プログラマのための数学勉強会@福岡 というイベントも主催していました。そうやってアウトプットを続けていれば、きっと仲間が集って、いつかみんなでワイワイできるようになるんだ、と信じて。</description>
    </item>
    
    <item>
      <title>機械学習でパラメータ推定 - 最尤推定法 -</title>
      <link>http://tkengo.github.io/blog/2016/08/22/maximum-likelyhood-estimation-by-machine-learning/</link>
      <pubDate>Mon, 22 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2016/08/22/maximum-likelyhood-estimation-by-machine-learning/</guid>
      <description>最尤推定法 (Maximum Likelyhood や Maximum Likelyhood Estimation と言われ、それぞれ頭文字を取って ML や MLE などとも言われる) は機械学習やコンピュータービジョンなどの分野で良く使われる推定法で、次のような条件付き同時確率を最大化することでパラメータの推定を行います。
$$ \hat{\theta} = \mathop{\mathrm{argmax}}\limits_{\theta} \mathrm{P}(x_1, x_2, \cdots, x_N|\theta) $$
これだけ見て「うん、アレね」と理解できる人はこの記事の対象読者ではなさそうですので、逆にいろいろ教えて下さい。この記事では理論の面から最尤推定法にアタックしてみます。数式成分が多めで、うっとなることもあるかもしれませんが、ゆっくり読んでいきましょう。
※この記事を読むにあたっては、確率論と微分の基礎知識程度は必要です。
尤度 いきなり応用問題から始めると必ず挫折するので、まずは一番簡単な問題設定から始めます。Wikipedia に 最尤推定 のページがありますので、この中で使われている例を参考に話を進めていきましょう。
見た目がまったく同じ 3 枚のコイン A, B, C があります。これらのコインはイカサマで、投げた時に表の出る確率がそれぞれ違います。
 コイン A は 1&amp;frasl;3 の確率で表が出る コイン B は 1&amp;frasl;2 の確率で表が出る コイン C は 2&amp;frasl;3 の確率で表が出る  この 3 枚のコインを箱の中に入れてシャッフルした後に 1 枚引きます。引いたコインを 10 回投げたら、表が 3 回、裏が 7 回出ました。あなたは A, B, C のどのコインを引いたでしょうか？
この問題設定は極めて単純です。単純すぎて最尤推定法を使わなくても解けるくらい簡単ですが、ここでは敢えて最尤推定法を使って解いてみます。最尤推定法は次の条件付き同時確率を最大化するパラメータ $\hat{\theta}$ を求めることでした。</description>
    </item>
    
    <item>
      <title>やる夫で学ぶ機械学習 - 対数尤度関数 -</title>
      <link>http://tkengo.github.io/blog/2016/06/16/yaruo-machine-learning6/</link>
      <pubDate>Thu, 16 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2016/06/16/yaruo-machine-learning6/</guid>
      <description>やる夫で学ぶ機械学習シリーズの第 6 回です。ロジスティック回帰の目的関数である尤度関数をもう少し詳しくみて、線形分離不可能な問題にどのように適用していくのかを見ていきます。
第 5 回はこちら。やる夫で学ぶ機械学習 - ロジスティック回帰 -
目次はこちら。やる夫で学ぶ機械学習シリーズ
対数尤度関数 やらない夫 尤度関数を微分してパラメータ $\boldsymbol{\theta}$ の更新式を求めてみようか。
やる夫 もう脳みそパンパンですお。
やらない夫 その前に、尤度関数はそのままだと扱いにくいから、少し変形しよう。
やる夫 扱いにくい？どういうことかお？
やらない夫 まず同時確率という点だ。確率なので 1 以下の数の掛け算の連続になることはわかるな？
やる夫 確かに、確率の値としては 0 より大きくて 1 より小さいものだお。
やらない夫 1 より小さい数を何度も掛け算すると、どんどん値が小さくなっていくだろう。コンピュータで計算する場合はそれは致命的な問題だ。
やる夫 あー、オーバーフローの逆かお。アンダーフロー。
やらない夫 次に掛け算という点だ。掛け算は足し算に比べて計算が面倒だ。
やる夫 小数点の計算とかあんまりやりたくないお。
やらない夫 そこで一般的には尤度関数の対数をとったもの、対数尤度関数を使う。
$$ \log L(\boldsymbol{\theta}) = \log \prod_{i=1}^n P(y^{(i)}=1|\boldsymbol{x})^{y^{(i)}} P(y^{(i)}=0|\boldsymbol{x})^{1-y^{(i)}} $$
やる夫 目的関数に対して勝手に対数をとったりして、答え変わらないのかお？
やらない夫 問題ない。対数関数は単調増加な関数だからだ。対数関数のグラフの形を覚えているか？
やる夫 確かこんな感じのグラフだお。
 やらない夫 それで正解だ。グラフがずっと右上がりになってることがわかるだろう。つまり単調増加な関数ってのは $x_1 &amp;lt; x_2$ ならば $f(x_1) &amp;lt; f(x_2)$ となるような関数 $f(x)$ だということだ。</description>
    </item>
    
    <item>
      <title>やる夫で学ぶ機械学習シリーズ</title>
      <link>http://tkengo.github.io/blog/2016/06/06/yaruo-machine-learning0/</link>
      <pubDate>Mon, 06 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2016/06/06/yaruo-machine-learning0/</guid>
      <description> 本シリーズ記事が書籍になりました。詳しくはこちら。   「やさしく学ぶ 機械学習を理解するための数学のきほん」を執筆しました  これは、機械学習に関する基礎知識をまとめたシリーズ記事の目次となる記事です。まとめることで知識を体系化できて自分自身の為にもなるので、こういうアウトプットをすることは大事だと思っています。ただ、普通にブログ記事を書くのも面白くないので、ちょっといつもとは違う方法でやってみようというのが今回のシリーズ記事。
2 ちゃんねるのキャラクターが登場人物として出てきて、彼らが会話して話が進んでいく「やる夫で学ぶシリーズ」という講義調の形式のものがあります。個人的にはやる夫で学ぶシリーズや 数学ガール のような会話形式で話が進んでいく読み物は読みやすいと思っています。さらに、先日みつけた やる夫で学ぶディジタル信号処理 という資料がとてつもなくわかりやすく、これの真似をして書いてみようと思い至りました。記事中のやる夫とやらない夫のアイコンは http://matsucon.net/material/mona/ こちらのサイトの素材を使わせていただきました。
第 2 回まで半年ほど前に公開していましたが、その後ブログ執筆の熱が冷めて放置されていました。が、実は下書きだけなら乱雑ながら第 5 回までは書いていて、周りにいる機械学習入門中の知り合い数名から下書きあるなら公開して欲しいと言われたので、お蔵入りさせるのも勿体ないし一気に清書して、この目次記事をつけて公開することにしました。今後、このシリーズ記事が増えるかどうかはわかりません。
まえがき このシリーズでは実践的な内容というよりかは、基礎的で理論的な部分をまとめていきます。機械学習をやり始めるにあたってまず最初にやったほうが良いのは、こういった座学のような記事を頑張って読むよりかは、やってみた系の記事を読みながら実際に手を動かしてコーディングしてみることです。いきなり機械学習の本や数式を眺めて理論から理解し始めるのは、数学に自信がある人や素養がある人以外は難しく、挫折してしまう原因となります。
今は良い時代になっていて、フレームワークを基盤として少しのコードを書いて、公開されている無料の学習用データを使えば、それらしいものが出来てしまいます。そういうもので感覚を掴んでから、理論を理解するのでも遅くはないと思っています。
とはいえ、プログラマであれば中身を知らないものをアレコレ触るのは怖さがあるというもの。理論の方に手をだしてみたくなったりもします。座学系の記事は、このブログ以外にもたくさん転がっているのでイロイロ読み比べて知識を自分のものにしていくのが大事です。一晩でなんとかなるものでもないですし、じっくりやっていきましょう。
対象  機械学習って最近よく聞くけど中身を良くしらない人 中身しらないけど機械学習って楽しそうだしなんか勉強してみたい人 数学が好きな人 ドヤ顔で機械学習のことを話したい人  ※上級者向けではありません。どちらかというとむしろ初学者向けです。
目次 記事 1 つ 1 つが長く、分割していくうちに記事数が多くなってきたので、目次を作りました。
 やる夫で学ぶ機械学習 - 序章 - やる夫で学ぶ機械学習 - 単回帰問題 - やる夫で学ぶ機械学習 - 多項式回帰と重回帰 - やる夫で学ぶ機械学習 - パーセプトロン - やる夫で学ぶ機械学習 - ロジスティック回帰 - やる夫で学ぶ機械学習 - 対数尤度関数 -  </description>
    </item>
    
    <item>
      <title>やる夫で学ぶ機械学習 - ロジスティック回帰 -</title>
      <link>http://tkengo.github.io/blog/2016/06/04/yaruo-machine-learning5/</link>
      <pubDate>Sat, 04 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2016/06/04/yaruo-machine-learning5/</guid>
      <description>やる夫で学ぶ機械学習シリーズの第 5 回です。分類問題を解くためのロジスティック回帰を見ていきます。
第 4 回はこちら。やる夫で学ぶ機械学習 - パーセプトロン -
目次はこちら。やる夫で学ぶ機械学習シリーズ
ロジスティック回帰 やる夫 分類問題を解くための素晴らしいアルゴリズムがあると聞きましたお。
やらない夫 今日は展開が早いな。
やる夫 回りくどいのは終わりだお。
やらない夫 では、今日はロジスティック回帰の話をしていこう。ロジスティック回帰は、パーセプトロンのように基本的には二値分類の分類器を構築するためのものだ。
やる夫 パーセプトロンよりは使い物になるのかお？
やらない夫 もちろんさ。ロジスティック回帰はいろんなところで使われているし、線形分離不可能な問題も解ける。
やる夫 それはナイスだお。
やらない夫 いつものように最初は簡単な具体例を示して概要を見ていこうか。
やる夫 よろしくお願いしますお。
やらない夫 問題設定はパーセプトロンの時と同じものを使おう。つまり、色を暖色か寒色に分類することを考えるんだ。
やる夫 それ、線形分離可能な問題だお？線形分離不可能な問題やらないのかお？
やらない夫 物事には順序ってものがあるだろう。先に基礎からやるんだよ。ロジスティック回帰も、もちろん線形分離可能な問題は解ける。まずそこから入って、その応用で最後に線形分離不可能な問題を見ていこう。
やる夫 基礎力つけるの面倒くさいけど、わかったお&amp;hellip;
やらない夫 ロジスティック回帰は分類を確率として考えるんだ。
やる夫 確率？暖色である確率が 80%、寒色である確率が 20%、みたいな話ってことかお？
やらない夫 そうだ、いつもとぼけた顔してる割には冴えてるじゃないか。
やる夫 顔は生まれつきだお。文句いうなお。
やらない夫 暖色、寒色のままでは扱いにくいのはパーセプトロンと同じだから、ここでは暖色を $1$、寒色を $0$ と置くとしよう。
やる夫 あれ、寒色は $-1$ じゃないのかお？
やらない夫 クラス毎の値が異なっていれば別になんでもいいんだが、パーセプトロンの時に暖色が $1$ で寒色が $-1$ にしたのは、そうした方が重みの更新式が簡潔に書けるからだ。
やる夫 なるほど。ロジスティック回帰の場合は暖色を $1$ で寒色を $0$ にした方が、重みの更新式が簡潔に書き表せるってことかお？
やらない夫 そういうことだな。話を進めよう。回帰の時に、未知のデータ $\boldsymbol{x}$ に対応する値を求めるためにこういう関数を定義したのを覚えているか？</description>
    </item>
    
    <item>
      <title>やる夫で学ぶ機械学習 - パーセプトロン -</title>
      <link>http://tkengo.github.io/blog/2016/06/03/yaruo-machine-learning4/</link>
      <pubDate>Fri, 03 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2016/06/03/yaruo-machine-learning4/</guid>
      <description>やる夫で学ぶ機械学習シリーズの第 4 回です。分類問題を解くための基礎、パーセプトロンを図形的な側面から覗いてみます。
第 3 回はこちら。やる夫で学ぶ機械学習 - 多項式回帰と重回帰 -
目次はこちら。やる夫で学ぶ機械学習シリーズ
問題設定 やらない夫 今日は分類問題について詳しく見ていく。
やる夫 分類問題かお。やる夫は、女の子が巨乳か貧乳かを分類して、想像を膨らませたいお。
やらない夫 そんなものは深夜に一人でニヤニヤしながらやるか、いつも引きこもってないで外に出て本物の女の子を見ることだな。
やる夫 冗談きついお、やらない夫。
やらない夫 分類の場合も、回帰の時と同じように具体例を示して、それを元に話を進めていったほうがわかりやすいな。
やる夫 それが良いお。具体例は、やる夫の将来の嫁さんくらい大事だお。
やらない夫 また意味のわからないたとえをありがとう。今回は分類の話なので、そうだな、色を分類することを考えてみよう。
やる夫 おっぱいじゃなくて、色を分類、するのかお？
やらない夫 おっぱいは忘れろ。たとえば、適当に与えられた色が、暖色系なのか寒色系なのかに分類する、という問題はどうだ？
やる夫 二値分類の問題かお。分類は確か教師あり学習だったから、つまりラベル付きの学習用データが要るってことかお？
やらない夫 そうだな、具体的には、色の情報と、その色が暖色なのか寒色なのか、というラベルを学習用データとして用意してやる必要がある。
やる夫 なるほど。
やらない夫 ところで、色と言えば RGB の三色を考えることができるが、最初は簡単な問題の方がいいから、緑のことは考えずに、赤と青だけに注目していこう。緑の要素は 0 に固定しようか。その方が図にもプロットできてわかりやすいしな。
やる夫 簡単になるなら歓迎だお。
やらない夫 たとえば、この色は暖色系、寒色系、どっちに見える？
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; #d80055  やる夫 んー、暖色系だお。
やらない夫 では、これはどうだ？
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; #2c00c8  やる夫 寒色系だお。
やらない夫 ということは、今 2 つの学習用データができた。緑の要素を 0 に固定しているから、#RRGGBB の GG の部分が 00 になっていることに注目だ。
   色 クラス     &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; #d80055 暖色   &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; #2c00c8 寒色    やる夫 うん、分類問題の場合の学習用データのイメージつかめたお。</description>
    </item>
    
    <item>
      <title>やる夫で学ぶ機械学習 - 多項式回帰と重回帰 -</title>
      <link>http://tkengo.github.io/blog/2016/06/02/yaruo-machine-learning3/</link>
      <pubDate>Thu, 02 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2016/06/02/yaruo-machine-learning3/</guid>
      <description>やる夫で学ぶ機械学習シリーズの第 3 回です。多項式回帰と重回帰について見ていきます。
第 2 回はこちら。やる夫で学ぶ機械学習 - 単回帰問題 -
目次はこちら。やる夫で学ぶ機械学習シリーズ
多項式回帰 やらない夫 さて、回帰の話にはもう少し続きがあるんだが。
やる夫 あんまり難しすぎるのは勘弁だお。
やらない夫 前回の延長だから、回帰が理解できていれば、そう難しい話ではないだろう。
やる夫 その前に、ちょっとおしっこいってくるお。
やらない夫 お前、そういうのは休憩中にやっとけよ&amp;hellip;
やる夫 わかったお！仕方ないから我慢するお！！
やらない夫 意外と根性あるな&amp;hellip;、ではこれから、前回の回帰の話をもう少し発展させていく。
やる夫 (あっ、ほんとに話を進めるのかお&amp;hellip;)
やらない夫 前回、俺たちは、求めたい関数をこのように定義して、パラメータである $\theta$ を求めた。
$$ f_{\theta}(x) = \theta_0 + \theta_1 x $$
やる夫 覚えてるお。$f_{\theta}(x)$ を使った目的関数を定義して、最急降下法でパラメータの $\theta$ を求めたんだお。
やらない夫 $f_{\theta}(x)$ は一次関数だから、関数の形は当然のことながら直線になる。そこは大丈夫だよな。
やる夫 なんか回りくどいお。前回やったことはちゃんと覚えてるから、復習ならしなくていいお。
やらない夫 そうか。では、本題に入るが、最初に示したプロットは、実は直線より曲線の方がよりフィットするんだ。
 やる夫 お、なるほど。確かに、曲線のグラフの方が、よりフィットしているように見えるお。
やらない夫 これは、関数 $f_\theta(x)$ を二次式として定義することで実現できる。
$$ f_{\theta}(x) = \theta_0 + \theta_1 x + \theta_2 x^2 $$</description>
    </item>
    
    <item>
      <title>Word2Vec のニューラルネットワーク学習過程を理解する</title>
      <link>http://tkengo.github.io/blog/2016/05/09/understand-how-to-learn-word2vec/</link>
      <pubDate>Mon, 09 May 2016 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2016/05/09/understand-how-to-learn-word2vec/</guid>
      <description>Word2Vec というと、文字通り単語をベクトルとして表現することで単語の意味をとらえることができる手法として有名なものですが、最近だと Word2Vec を協調フィルタリングに応用する研究 (Item2Vec と呼ばれる) などもあるようで、この Word2Vec というツールは自然言語処理の分野の壁を超えて活躍しています。
実は Item2Vec を実装してみたくて Word2Vec の仕組みを理解しようとしていたのですが、Word2Vec の内部の詳細に踏み込んで解説した日本語記事を見かけることがなかったので、今更感はありますが自分の知識の整理のためにもブログに残しておきます。なお、この記事は Word2Vec のソースコードといくつかのペーパーを読んで自力で理解した内容になります。間違いが含まれている可能性もありますのでご了承ください。もし間違いを見つけた場合は指摘してもらえると修正します。
※この記事を読むにあたっては、ニューラルネットワーク及び確率的勾配降下法に関する基礎知識程度は必要です。
Word2Vec Word2Vec の正体は、隠れ層と出力層の 2 層からなる単純なニューラルネットワークです。このニューラルネットワークに次々に単語を読み込ませて重みを学習させていくのですが、Word2Vec で獲得できる単語のベクトル表現というのは実はネットワークの重みそのものです。入力データに対する &amp;ldquo;良い表現&amp;rdquo; を獲得するという意味では自己符号化器 (オートエンコーダ) に近いものがあると思います。
Word2Vec のネットワークのアーキテクチャとしては CBoW 及び Skip-gram と呼ばれる 2 種類があり、また学習を高速化するテクニックとして Hierarchical Softmax 及び Negative Sampling の 2 種類が提案されています。Word2Vec 論文の著者が公開しているオリジナルの C のソースコードでは両方のアーキテクチャ及び高速化テクニックが実装されていますが、この記事では Skip-gram と Negative Sampling について書いていきます。CBoW 及び Hierarchical Softmax については機会があれば別途記事を書きます。
Skip-gram でモデル化する Skip-gram とは、ある単語が与えられた時、その周辺の単語を予測するためのモデルです。たとえば以下のような単語の集合があったとしましょう。このようなものはボキャブラリと呼ばれます。
{ I, am, a, programmer, like, dog, cat }  これらの単語を使って文章を作ってください、と言われたら I am a programmer や I like a dog などの文章がすぐに思い浮かぶでしょう。ここで作った文章中の I という単語に注目すると、その次には am や like が現れて、さらにその次には a があって、それに続いて programmer や dog があります。しかし、I の次にいきなり programmer や dog といった単語はあまり現れないでしょう。つまり I という単語の周辺にはどういった単語が出現しやすいか、という確率を考えることができます。</description>
    </item>
    
    <item>
      <title>畳み込みニューラルネットワークによるテキスト分類を TensorFlow で実装する</title>
      <link>http://tkengo.github.io/blog/2016/03/14/text-classification-by-cnn/</link>
      <pubDate>Mon, 14 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2016/03/14/text-classification-by-cnn/</guid>
      <description>先日、九工大や東工大などの学生さんが LINE Fukuoka に遊びにきてくれました。せっかく学生さんが遊びに来てくれるので LINE Fukuoka の社員と学生さんとで LT 大会をやろうという運びになって、学生さんは普段やっている研究内容を、LINE Fukuoka 側はなんでも良いので適当な話を、それぞれやりました。当日は私を含む LINE Fukuoka の社員 3 人と、学生さん 2 人の合計 5 人が LT をしました。詳細は LINE Fukuoka 公式ブログに書かれていますので、興味のある方は御覧ください。
[社外活動/報告] 学生を招いてのエンジニア技術交流会を開催しました。
LT に使った資料は公開してもいいよ、とのことだったので、せっかくなので公開。当日はテキスト分類のデモをやったのですが、残念ながらデモ環境までは公開できませんでした。ただ、ソースコードは github で公開していますので見ることができますので後ほどリンクを貼っておきます。
  この LT では時間が 15 分しかなくて実装の話は一切できなかったので、せっかくなのでこの記事では実装の話を書こうと思います。実装にあたっては Google 製の機械学習フレームワークの TensorFlow を利用しています。実際は、この実装の元になった実装があって、本当はそれをそのまま使いたかったのですが、自分が適用したいタスクに対してはいくつか問題点があったのと、TensorFlow の感覚を掴みたかったので、自分でスクラッチで実装しました。 以下ソースコードです。
tkengo/tf/cnn_text_classification
また、もし時間があれば、この記事を読む前に以下のリンク先も合わせて読んでおくとより理解が深まると思います。
 Convolutional Neural Networks for Sentence Classification 実装の元になっている論文。 Implementing a CNN for Text Classification in TensorFlow 私の実装の元になったオリジナル実装についての記事。英語。 自然言語処理における畳み込みニューラルネットワークを理解する 上記ブログと同じ作者が執筆した別記事を私が日本語に翻訳したもの。  なお、本記事では実装の詳しい内容を書いていますので、以下のような方を対象読者と想定しています。
 ニューラルネットワークに対する簡単な基礎知識はある TensorFlow の MNIST For ML Beginners チュートリアルは完了して基本的な概念と使い方の知識はある  完全に初心者だという方は少し難しい内容かもしれませんが、別に当てはまってなければ読んではダメというものでもないので、興味のある方は是非読み進めてみてください。</description>
    </item>
    
    <item>
      <title>自然言語処理における畳み込みニューラルネットワークを理解する</title>
      <link>http://tkengo.github.io/blog/2016/03/11/understanding-convolutional-neural-networks-for-nlp/</link>
      <pubDate>Fri, 11 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2016/03/11/understanding-convolutional-neural-networks-for-nlp/</guid>
      <description>最近、畳み込みニューラルネットワークを使ったテキスト分類の実験をしていて、知見が溜まってきたのでそれについて何か記事を書こうと思っていた時に、こんな記事をみつけました。
http://www.wildml.com/2015/11/understanding-convolutional-neural-networks-for-nlp
畳み込みニューラルネットワークを自然言語処理に適用する話なのですが、この記事、個人的にわかりやすいなと思ったので、著者に許可をもらって日本語に翻訳しました。なお、この記事を読むにあたっては、ニューラルネットワークに関する基礎知識程度は必要かと思われます。
※日本語としてよりわかりやすく自然になるように、原文を直訳していない箇所もいくつかありますのでご了承ください。翻訳の致命的なミスなどありましたら、Twitterなどで指摘いただければすみやかに修正します。
以下訳文 畳み込みニューラルネットワーク (CNN) という言葉を聞いた時、普通はコンピュータービジョンのことを思い浮かべるでしょう。CNN は過去に画像分類の分野においてブレークスルーを引き起こし、今日では Facebook の写真の自動タギングから自動運転車に至るまで、ほとんどのコンピュータービジョンシステムの中核となっています。
そして近年、自然言語処理 (NLP) の領域の問題に対しても CNN が適用されはじめ、いくつか興味深い結果を得ています。この記事では CNN とはいったい何なのかということ、またどのようにして NLP の領域で使われるのか、ということを説明してみたいと思います。コンピュータービジョンでのユースケースを話した方が CNN においてはいくぶん直感的ですので、まずはそこから始めたいと思います。そしてゆっくりと NLP の話題へ移っていきましょう。
畳み込みとは？ 私は、畳み込みについては、行列に適用されるスライド窓関数 (sliding window function) として考えるとわかりやすいと思います。言葉でこう書くとちょっと難しいかもしれませんが、視覚的に表してみると非常にわかりやすいです。
 3x3 の畳み込みフィルタ。引用元: http://deeplearning.stanford.edu/wiki/index.php/Feature_extraction_using_convolution  左側にある行列は白黒の画像を表していると考えてください。行列の各要素はそれぞれ画像の 1 つのピクセルに対応しており、0 が黒、1 が白です (一般的には 0 から 255 の間の値を取るグレースケールの画像)。スライド窓はカーネル (kernel) やフィルタ (filter) または特徴検出器 (feature detector) などと呼ばれます。ここでは 3x3 のフィルタを使っており、そのフィルタの値と行列の値を要素毎に掛けあわせ、それらの値を合計します。この操作を、行列全体をカバーするようにフィルタをスライドさせながら各要素に対して行っていき、全体の畳み込みを取得します。
でも結局これで何が出来るの？と不思議に思いませんか。ここで直感的な例を挙げてみましょう。
各ピクセルとその周囲を平均して画像をぼかす:  
各ピクセルとその周囲の差分をとってエッジを検出する: (これを直感的に理解するためには、ピクセルの色が周囲の色と同じであるような色の変化がなめらかな部分で、どういうことが起こるのかを考えてみましょう。そういった部分にこのフィルタを適用すると、可算が相殺されて結果的には 0、つまり黒になります。逆に、明度が極端に違うエッジの部分であれば - これはたとえば白から黒へ移り変わっている部分 - においては、差分が大きくなり結果的には白くなります。)
 
GIMP のマニュアル には、ここで紹介した以外のサンプルがいくつか含まれています。畳み込みについてより詳しく理解したければ Chris Olah の記事 も読んでみることをオススメします。</description>
    </item>
    
    <item>
      <title>やる夫で学ぶ機械学習 - 単回帰問題 -</title>
      <link>http://tkengo.github.io/blog/2016/01/04/yaruo-machine-learning2/</link>
      <pubDate>Mon, 04 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2016/01/04/yaruo-machine-learning2/</guid>
      <description>やる夫で学ぶ機械学習シリーズの第 2 回です。回帰について見ていきます。
第 1 回はこちら。やる夫で学ぶ機械学習 - 序章 -
目次はこちら。やる夫で学ぶ機械学習シリーズ
問題設定 やらない夫 今日は回帰について詳しく見ていく。
やる夫 回帰って響きがカッコいいお。
やらない夫 ここからは、より具体的な例を混じえながら話を進めていこう。
やる夫 具体例は、やる夫の明日のお昼ごはんぐらい大事だお。
やらない夫 まったく意味がわからないたとえなんだが&amp;hellip;。そうだな、たとえば、主人公の攻撃力によって、敵キャラに与えるダメージが決まるゲームがあるとしよう。
やる夫 よくある設定だお。
やらない夫 ダメージには揺らぎがあって、常に同じダメージを与えられるとは限らない。さて、実際に何度か敵キャラに攻撃してみて、その時の攻撃力と与えたダメージをグラフにプロットしてみると、こんな風になっていたとしよう。
 やる夫 なるほど。攻撃力が高くなればなるほど、与えるダメージも大きくなっているお。
やらない夫 やる夫はコレを見て、攻撃力が 10 の時にどれくらいダメージを与えられるかわかるか？
やる夫 馬鹿にしてるのかお！そんなの簡単だお。だいたい 60 前後くらいだお？
 やらない夫 そうだな。俺たちはこれから機械学習を使って、今やる夫がやったように、攻撃力からダメージを予測していく。
やる夫 そんなの、このプロットを見れば、だいたい誰にでもわかるお？
やらない夫 それはこの問題設定が単純だからだよ。実際に機械学習を使って解きたい問題は、複雑な問題であることがほとんだ。そういうものを機械にまかせるために、データから学習させるんだよ。それが機械学習だ。後からもっと複雑な問題も見ていくから、その時もまた同じことが言えるかどうかだな。
やる夫 ふーん。
最小二乗法 やる夫 どうやって学習していくんだお？
やらない夫 関数をイメージするんだ。このプロットの各点を通る関数の形がわかれば、攻撃力からダメージがわかるだろ。ただし、ダメージにはノイズが含まれているから、関数がきっちり全ての点を通るわけじゃない。
 やる夫 これは一次関数だお！一次関数は、切片と傾きがわかれば関数の形が決まるから、それを調べることになるのかお？
やらない夫 冴えてるな。俺たちがいまから考える関数は、切片と傾きを $\theta$ を使って表すと、こんな風になる。
$$ y = \theta_0 + \theta_1 x $$
やる夫 うっ、式が出てくると急に数学っぽくなるお&amp;hellip;、$\theta$ ってなんだお。
やらない夫 $\theta$ はこれから俺たちが求めていく未知数だ。パラメータとも言う。文字は別になんでもいいんだが、統計学の世界では、未知数や推定値を $\theta$ で表すことが多いので、今回も $\theta$ を使っただけだ。</description>
    </item>
    
    <item>
      <title>やる夫で学ぶ機械学習 - 序章 -</title>
      <link>http://tkengo.github.io/blog/2016/01/03/yaruo-machine-learning1/</link>
      <pubDate>Sun, 03 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2016/01/03/yaruo-machine-learning1/</guid>
      <description>やる夫で学ぶ機械学習を書いてみました。
やる夫で学ぶ機械学習シリーズの第 1 回です。記事がとても長くなったので、分割してます。
目次はこちら。やる夫で学ぶ機械学習シリーズ
機械学習 やる夫 機械学習やってみたいけど、そもそもどうすりゃいいかまったくわからんお。Wikipedia を見たけど、何を言ってるのかさっぱりだお&amp;hellip;
やらない夫 お前、Wikipedia でわかるわけがないだろ、常識的に考えて&amp;hellip;
やる夫 そうなのかお&amp;hellip;。しかも、やたら数式が出てきて、日本語でおｋって言いたくなるお。
やらない夫 確かに数式は出てくるが、そもそも数式というのは日本語で言うと長ったらしくなるものを誰にでもわかるように厳密で簡潔に表してるものなんだぞ。というか、やる夫は機械学習で何がしたいんだ？
やる夫 えっ&amp;hellip;、あーえーっと、ほら、アレだお&amp;hellip;なんか、こう、パーッと、いい感じの&amp;hellip;
やらない夫 お前、ただ機械学習って言いたいだけだろ&amp;hellip;
やる夫 そんなことないお！！やる夫は流行に敏感なんだお！！！
やらない夫 まず機械学習で何をやりたいかを考えることは大事なことなんだが&amp;hellip;、じゃぁ質問を変えよう。機械学習はどういうところで使われていると思う？
やる夫 スパムメールの判定とか、文字認識、金融市場の予測なんかに使われてるお。
やらない夫 その通りだ。よく知ってるじゃないか。
やる夫 Wikipedia に書いてあったお。
やらない夫 実際は、それ以外にも幅広い分野で利用されているんだ。
やる夫 万能タイプなんだお。
やらない夫 そんなことはないぞ。機械学習があればなんでもできるようになるわけじゃない。どこに適用できて、どこに適用できないのかを見極めるのも大事なことだ。それに、大抵の場合は大量の学習データを人手で用意する必要もあるんだ。
やる夫 機械学習ってそんなもんなのかお&amp;hellip;、ちょっと面倒くさいお。勉強するモチベーションさがってきたお。
やらない夫 まあそういうな。機械学習のおかげで、今まで出来なかったことが出来るようになった事例はたくさんあるんだ。勉強してみると案外おもしろいもんだぞ。
やる夫 ふーん。そこまで言うなら勉強につきあってやってもいいお。
やらない夫 なんで急に上から目線なんだよ。
やる夫 ここでやる夫が勉強をやめると、話が続かないんだお。
やらない夫 まったく&amp;hellip;。じゃぁ最初は機械学習でどういう問題を扱えるかという話からだ。
回帰、分類、クラスタリング やらない夫 さっき言ったように、機械学習はどんな問題でも扱えるわけじゃない。機械学習が得意とする問題には、主に以下のようなものがある。
 回帰 分類 クラスタリング  やる夫 統計学で同じような単語を聞いたことがあるお。回帰分析とか、統計的分類とか。
やらない夫 やる夫は統計学に明るいのか。
やる夫 えっ、いや、Wikipedia で読んだことあるだけだお&amp;hellip;
やらない夫 確かに回帰や分類は、統計学で言うところのそれと同じだな。どこが違うかって言われると微妙だが、その辺を気にしてもあまり建設的ではないから、話を先に進めよう。
やる夫 やらない夫がはぐらかしたお。
やらない夫 いいんだよ。とりあえず、回帰の話をしようか。英語で Regression とも言う。回帰は、わかりやすく言うと学習データとして &amp;ldquo;連続するデータ&amp;rdquo;、例えば時系列データ、などが与えられた時、未知のデータがどういうものかを予測するものだ。</description>
    </item>
    
    <item>
      <title>プログラマと数学</title>
      <link>http://tkengo.github.io/blog/2015/12/14/math-advent-calendar-2015-14th/</link>
      <pubDate>Mon, 14 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2015/12/14/math-advent-calendar-2015-14th/</guid>
      <description>この記事は Math Advent Calendar 2015 の 14 日目の記事です。
他のブログが本格的な数学のお話を記事にしている中、僕はというとそんなに高度な数学の話ができるわけではないので、自身の数学との関わり方や、また今年に入って開催してきた プログラマのための数学勉強会@福岡 の振り返りとその今後についてを書いていきます。同じような境遇の人が少しでもこっち側の世界に足を踏み入れれるようになることを願って。
プログラマから見た数学の楽しさ アルゴリズムやディープラーニング、ビッグデータ、WebGL など、よく聞くいわば流行りのワードについて、そういうものを使った技術やサービスを見つけた時「実際、中身はどういう風に動いているんだろう？」という好奇心はプログラマであれば潜在的には誰でも持っているのではないでしょうか。それは私達プログラマが、普通の人よりもより身近に普段からそういうことに接しているからだと思いますし、何よりも夢があるからです。
Google は画像を投げるだけで高速に画像の中身を識別できるようになりました。Facebook は顔写真から個人を予測することができるようになりました。映像や 3D の技術を使ったプロジェクションマッピングなども有名になりました。最先端の技術には夢が詰まっています。
ご存知のように、そういった技術の背後には高度な数学な知識が必要なものもあります。完全に理解するのはとても無理かもしれません。でも、それでも数学を知っているのと知っていないのでは、そういった技術をより身近に感じることができるかどうかには雲泥の差があります。
前にも書きましたが、数学という道具はプログラミングにおいて必ずしも必要なものではありません。しかし数学はプログラミングにおいて視野を広げるための武器になり得ます。ディープラーニングの仕組みがわかると楽しいし、ましてや自分で実装ができた日には興奮して眠れないことでしょう。
考えることの楽しさ 数学にはもう一つ僕が好きな側面があります。考える事の楽しさです。たとえば数学にはよく「公式」というものが出てきます。二次方程式の解の公式 (1) とか、三角関数の加法定理 (2) (3) とか。
$$ x = \frac{-b\pm\sqrt{b^2-4ac}}{2a} \tag{1} $$ $$ \sin(\alpha+\beta) = \sin\alpha\cdot\cos\beta + \cos\alpha\cdot\sin\beta \tag{2} $$ $$ \cos(\alpha+\beta) = \cos\alpha\cdot\cos\beta - \sin\alpha\cdot\sin\beta \tag{3} $$
中学生や高校生の頃、こういう式はよく暗記していたと思います。でも歴史上初めてこれを発見した人達は、何かしらの方法でこれらの公式を導出してきたはずです。そして同様に僕達も丸暗記なんてしなくても、いろんな方法で公式を「導出」することだってできるのです。もちろん暗記が完全に悪というとそうではないと思います。我々には有限の時間しかありませんので効率よく知識を頭に詰め込んでいく必要があります。
ただ、それだけだと数学はまったくおもしろくありません。数式を見つめて、数式をいじって、数式と戯れます。裏に隠れてるものを見つける努力をします。代数的な解釈や、図形的な解釈もしてみます。グラフを書くのも良いです。そうやって自分で「考えて」みます。一見、まったく関係のないように見えることでも実は繋がっていたりします。
$(x+a)(x+b)=c$ という式をみて何を思い浮かべるでしょうか。とりあえず $x^2 + ax + bx + ab = c$ という風に展開するのは誰でも思いつきそうです。$x$ について解いてみますか？$x \ge 0, a \ge 0, b \ge 0$ という条件を付け加えて、縦が $(x+a)$ で、横が $(x+b)$ という長方形の面積が $c$ になる、という解釈をしてみるのもありでしょう。下図の赤は $x^2$ 、黄色は $ax$ 、緑は $bx$ 、白は $ab$ なので、全部たすと長方形の面積 $c$ になるし、実際にさっき展開した式と一致しています。</description>
    </item>
    
    <item>
      <title>文字列検索ツール highway は &#34;高速&#34; を謳うために何をやってきたのか</title>
      <link>http://tkengo.github.io/blog/2015/12/11/architecture-of-highway/</link>
      <pubDate>Fri, 11 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2015/12/11/architecture-of-highway/</guid>
      <description>先日、社内で highway のアーキテクチャの話をする機会があったので、スライドを作って話しました。秘密情報というわけでもないので、せっかくなので公開したいと思います。ということで、この記事では highway のアーキテクチャを簡単に紹介します。C で実装されており、実装にあたっては既存のツールよりも高速に動作させるためにいくつもの工夫をしたので highway の内部がどうなっているのか興味がある方は読んでみると面白いかもしれません。
highway についての詳細はこちら。
highway という高速検索ツールを作ってみました
資料   以下、補足や簡単な説明などをつらつらと。
文字列探索アルゴリズム highway ではリテラルによる検索は、以下の論文を参考に実装しています。
A simple fast hybrid pattern-matching algorithm
通称 FJS 法と呼ばれるこのアルゴリズムは Boyer-Moore と Knuth–Morris–Pratt をベースにしています。Boyer-Moore と Knuth-Morris-Pratt についてはスライド内で解説していますが、FJS についてはアルゴリズム開発者の一人である Jennings さんの Web サイトで Java アプレットを使ったデモを公開しており、実際にどのように検索が進んでいくのかがとてもわかりやすく可視化されていますので、動作の解説はそちらにおまかせしました。是非以下の URL から覗いてみてください。
http://www.cgjennings.ca/fjs/
また、スライドには書いてありませんが highway は正規表現による検索もサポートしており、その部分には OSS の正規表現ライブラリである Onigmo(鬼雲) を利用しています。
Onigmo
マルチスレッド highway はマルチスレッドで動作し、内部は以下の要素で構成されます。
 メインスレッド
検索対象ファイルを再帰的に探索し、.gitignore の無視パターンを加味しつつ、対象ファイルをキューに追加していくのが仕事です。
 ファイルキュー
検索対象ファイルが溜まっていくキューです。他の全てのスレッドからアクセスされるため、キューへのアクセスは排他制御されています。
 検索スレッド
1 ファイルの検索処理が 1 スレッドに割り当てられます。スレッドはキューの先頭にあるファイルを取り出して検索し、処理がが完了するとキューのアイテムに対して探索済みのフラグを付与します。</description>
    </item>
    
    <item>
      <title>理解してるつもりの SSL/TLS でも、もっと理解したら面白かった話</title>
      <link>http://tkengo.github.io/blog/2015/12/01/https-details/</link>
      <pubDate>Tue, 01 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2015/12/01/https-details/</guid>
      <description>Web サービスを構築する際に SSL/TLS を導入することはもはや当然となってきました。共通鍵暗号/公開鍵暗号の使われ方や証明書のやりとりなど、基本的な部分について解説されている記事はインターネット上に豊富にあるため理解している方も多いのではないでしょうか。しかし、ことセキュリティに関しては常にその重要性が叫ばれており、もっと突っ込んだ部分を理解したいという欲求がこの記事を書くきっかけになりました。
そのため、この記事では SSL/TLS の導入部分ではなく、以下のような内容に焦点をあてて書かれています。
 具体的な暗号化アルゴリズムの実態 証明書やデジタル署名、メッセージ認証の使われ方 SSL/TLS のプロトコルレベルでのフロー  とはいえ、本などでしっかり体系的に勉強したわけではなく、長い時間をかけて、インターネットに散らばっている知識から自分が得たものを、自分の頭の中の整理のために自分なりにまとめた記事になりますので、間違いがあれば突っ込んでくれると喜びます。なお、簡略化のため以下より SSL/TLS は単に TLS と表記します。
暗号化 暗号スイート 突然ですが暗号スイート (Cipher Suites) という言葉を知っているでしょうか。TLS は暗号通信のためのプロトコルですが、暗号通信と一言で言ってもその通信フローではいくつもの暗号技術やハッシュ関数が各所で組み合わされながら使われています。通信のあの部分にはこの暗号技術を使い、また別の部分にはこの暗号技術を使う、という組み合わせがプロトコルに予め定義されており、それらを 暗号スイート といいます。
例えば TLS ではアプリケーション層のデータは共通鍵方式で暗号化され、その共通鍵を公開鍵方式で暗号化してサーバーに送信するという手順がありますよね。(※実際には共通鍵そのものを暗号化するわけではありません。詳細は後述。) ここで、共通鍵暗号と公開鍵暗号のアルゴリズムは 1 つではありません。これらのアルゴリズムは複数存在し、それぞれのアルゴリズムによって特徴や暗号の強度が違います。それらをクライアントとサーバーの間で提示し合って、どの組み合わせを使うのかを決めます。つまりクライアントはどの暗号化アルゴリズムの組み合わせを使うのかを自由に選択することができます。ただし、もちろんその組み合わせにサーバーが対応していないとダメです。(※ここでは通信の暗号化と鍵交換を例に出しましたが、それ以外にもいくつかアルゴリズムを切り替えることができる箇所があります。)
   架空のクライアント 通信の暗号化に使うアルゴリズム 鍵交換に使うアルゴリズム     クライアントA 3DES RSA   クライアントB AES (128bit) RSA   クライアントC AES (256bit) DH    apache や nginx の設定をしたことがあれば以下の様な行を見たことがある人も多いのではないでしょうか。(※ 下記は nginx の設定。apache の場合は SSLCipherSuite です。)</description>
    </item>
    
    <item>
      <title>highway という高速検索ツールを作りました</title>
      <link>http://tkengo.github.io/blog/2015/10/19/release-highway/</link>
      <pubDate>Mon, 19 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2015/10/19/release-highway/</guid>
      <description>いまや grep、ack、ag、pt、sift など様々な grep ツールが存在し、高速 grep ツール戦線が激化している昨今ですが、いかがお過ごしでしょう。私は普段から検索ツールには pt を使っていますが、ふとしたことから文字列探索アルゴリズムに興味がわいてきて highway という高速パターンマッチングツールを開発しました。pt や sift が流行りの Go 言語で実装されている中、我が道を行く highway は C 言語での実装にしました (単に Go 言語を知らないだけとも言う＼(^o^)／)。
highway (github)
highway とは マルチスレッドで動作する高速パターンマッチングツールです。速そうな名前をつけたくて「高速」でググったら「高速道路」がたくさん出てきたのでこの名前になりました。そりゃそうだ。
機能 基本的な機能としては pt とほぼ同じです。しかし速度については pt 以上かな、と。
 ag / pt / sift 相当(もしくはそれ以上) の速度でのパターンマッチング。 正規表現での検索。 UTF-8 以外に EUC-JP と Shift_JIS のサポート(だって日本人だもん)。 デフォルトで .gitignore 内のパターンを検索対象から除外。  インストール Mac OS X homebrew で一発です。
$ brew tap tkengo/highway $ brew install highway  Fedora Core yum でインストールできます。その際にリポジトリを追加する必要があります。</description>
    </item>
    
    <item>
      <title>プログラマのための数学勉強会@福岡を開催しました</title>
      <link>http://tkengo.github.io/blog/2015/09/07/mathematics-for-programmer-first/</link>
      <pubDate>Mon, 07 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2015/09/07/mathematics-for-programmer-first/</guid>
      <description>こんにちは。
先日 プログラマのための数学勉強会@福岡 を LINE Fukuoka のオフィスで開催しました。当日はうちの社員も含めて全体で40名程度の人々で会場が埋まりました。この規模のイベントは主催したことがなかったので少々 (いや、かなり) 不安でしたが、多くの参加者に来て頂きまして無事にイベントを終えることができたので、とりあえずホッとしています。
Togetter にハッシュタグがついているツイートもまとめました。
プログラマのための数学勉強会@福岡ツイートまとめ
タイムキーパー役がいなかったので終了時間が予定より30分程オーバーしてしまいましたが、当日は以下の様なタイムテーブルの予定でした。
   時間 タイトル 発表者     18:30 - 19:00 受付    19:00 - 19:30 数学とプログラミングの世界を楽しもう - ProjectEuler - @tkengo   19:30 - 19:50 暗号技術を支える素数 @shoyan__   20:00 - 20:30 ぼくの実装した最弱のディープラーニング @kis   20:30 - 21:00 圏論超絶基礎の基礎の基礎入門 @nobkz    数学とプログラミングの世界を楽しもう - ProjectEuler - 僕の話でした。
福岡での初開催ということで、最初から少し難易度を下げた話題を取り扱おうと思っていました。ということで、題材にプロジェクトオイラーの初級の問題を選んで、その問題の紹介と効率的な解き方の解説を入れてみました。スライドでは数列に関する 4 つの問題とその効率的な解き方を紹介していて、当日は時間がなかったので 1 〜 3 つ目に紹介した問題の解説は飛ばして、4 つ目の問題の解説だけやりました。</description>
    </item>
    
    <item>
      <title>「目に見えるパーセプトロン」という資料を作ったので公開します</title>
      <link>http://tkengo.github.io/blog/2015/08/21/visual-perceptron/</link>
      <pubDate>Fri, 21 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2015/08/21/visual-perceptron/</guid>
      <description>先日、社内の勉強会でネタが募集されていたので機械学習、特にパーセプトロンについてしゃべりました。パーセプトロン自体は非常に単純なモデルで、理解も実装も比較的容易で、それゆえに様々なものの基礎になっています。近年、深層学習と呼ばれる学習を何層にも渡って行うような概念が話題になっていますが、そこに出てくるニューラルネットワークは一種の多層パーセプトロンでもあります。ここ数年での機械学習や深層学習の進歩のスピードは素晴らしいものがありますが、そんな中で基礎的な部分を押さえておくことはより大事になってくるのではないでしょうか。
社内勉強会で使ったスライドでは、簡単な機械学習の概要とパーセプトロンの仕組みを解説してみました。インターネット上に公開したので、このブログでも紹介しておきます。

  補足 いくつか資料の補足をしておきたいと思います。
学習について 基本的には対象データから素性を抽出して、それを識別しながら重みが間違っていれば更新していくという流れです。素性という単語は他にも特徴量と呼ばれたりもします。スライドには、とりあえず全ての学習データが無くなるまで繰り返していくと最終的には理想的な(重みベクトルを法線とする)直線が引かれますが、そうならないこともあるのでその場合は何度か学習を繰り返します。
学習の終了判定は一定の判断基準を持って学習の終了とするか、もしくはある一定回数だけ学習を繰り返したら終了とするかのどちらかになると思います。どちらを選ぶかはケースバイケースですが、勉強や練習のためにパーセプトロンを実装するだけであれば、後者の方法の方がはるかに簡単です。
線形分離不可能について パーセプトロンは基本的に線形分離可能な問題にしか適用することができません。それは資料のまとめの部分にも書いてある通りなのですが、あるテクニックを使うと線形分離不可能な問題にも適用することができます。
たとえば分類対象データから抽出した素性が二次元ベクトルでそれらが 2 つのクラスに分類されるんだけど、直線を引いて 2 つに分割できない、すなわち線形分離不可能な問題だった場合、その抽出された素性をより高次元な空間に写像してあげます。たとえばとある二次元の素性 (x, y) があったとすると、これを (x, y, x^2, y^2) などという四次元の空間に写像してあげて、この素性をパーセプトロンに渡して学習を繰り返すと、二次元では線形分離不可能だった問題が四次元で線形分離可能になる場合があります。
これをカーネルトリックと言います。
目に見える スライドのタイトルにもある通り 目に見える というところが推しポイントです。何が目に見えるのかというと学習の過程です。スライドだと二次元の空間において学習していく過程を簡単に説明しました。その部分を読んだ上で今度は三次元空間において学習していく過程を表現したものを作ってみました。それがこれです。
目に見えるパーセプトロン
three.js を使って作っています。まずページを開くと初期状態で以下のようなものが表示されます。各点が三次元の素性ベクトルを空間にプロットしたものです。
ここでスペースキーを押すたびに学習データを読み込んで学習を進めていきます。その際に都度、重みベクトル (ピンク色の矢印) を更新して空間を分割する平面 (資料では二次元なので 線 だったけど、これは三次元なので平面) が更新されていく様子がわかると思います。学習データがなくなるまで学習が進むと、青と緑の点が綺麗に 2 分割されている状態が出来上がると思います。
マウスでグリグリ視点を動かすことも出来るのでいろいろいじってみてください。ちなみにソースコードはこちら。
https://github.com/tkengo/perceptron_visualization
それでは。</description>
    </item>
    
    <item>
      <title>福岡でプログラマのための数学勉強会を開催することにしました</title>
      <link>http://tkengo.github.io/blog/2015/08/15/mathematics-for-programmer/</link>
      <pubDate>Sat, 15 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2015/08/15/mathematics-for-programmer/</guid>
      <description>福岡の地で プログラマのための数学勉強会@福岡 を開催することになりました。初です。
プログラミングをやる上で数学って基本的には必要ないし、別に数学を知らなくてもほとんどのことは問題なく進めることができます。でも OpenGL や WebGL、機械学習、深層学習、画像解析、映像解析、音声解析、統計、データマイニング、などなど高度な技術は数学の知識が必要とされています。このあと書きますが、僕自身そういった技術に興味を持ち始めて数学をやり直し始めたのですが、数学好きな身としてはどうしても周りにそういう友達が欲しくなるんですよ。そういうことをある日つぶやいたら、あれよあれよと話が進んで開催まで至りました。
数学好きや数学に興味を持ってるプログラマの人達が集まって、数学をつかって何かやっていることを紹介しあったり、数学について語り合ったり、そして他の参加者と刺激しあったりできる、そういった勉強会を目指しています。
内容 内容としては数学とプログラミングを絡めたものであればなんでもよくって、あまりにも難解じゃなければ多少が数学色が強くてもいいかなーとは思っています。難しいやつでも参加者にわかるように噛み砕いて柔らかく説明してくれるなら大丈夫だと思いますが、そうでない場合は僕も含め 1 ミリも理解できないまま終わってしまうのも良くないですし。
ちなみに僕は数学の問題をプログラミングを使って解いて遊ぶというサイトの紹介と、いくつかの問題の解き方の紹介をやろうかと思っています。
動機 それは、会社とは全然関係のないところで、完全なる個人的な趣味で OpenGL や画像解析、機械学習を学んでいくうちに「これはもっと数学の基礎からやりなおさねば」と思いはじめた20代最後の夏のこと。幸いなことに中学生の頃から数学は大好きで、高校も理系クラスに進み、大学も情報系の学部に進んで授業では普通に線形代数や解析学、確率統計などを学んできたので、数学をやり直すことにまったく抵抗はありませんでした。まあ当時の僕は数学が「好き」ではありましたが、数学が「デキル」かというと、、、もうわかりますね？
そんなこんなで数学をやり直しはじめて早1年。僕の数学の実力はこれまでの伸びシロを埋めるようにメキメキと伸びはじめ、周りにたくさんの数学の友達もできて、ついでに彼女もできて&amp;hellip;ってうまくいくわけがなくてね。。。基本一人ぼっちでやってます。それにやっぱ数学って本気でやるとマジでむずかしいじゃないですか、理解できたーと思っても絶対あと2回くらいは変身を残してるじゃないですか。モノによっては日本語/英語に関わらず論文を読んだり、それを実装したりするくらいまでは出来るようになってきましたが、さすがに一人でやってるとモチベーションがもたない。
そんな悩みを持ちつつ日々を過ごしていると プログラマのための数学勉強会 というなんとも僕のタメにあるようなイベントを見つけました。が、しかし！会場が東京でした！僕は九州人なので物理的に参加できず！
あぁ・・・なんて楽しそうなんだ。僕も参加したいぞ・・・その想いは日に日に強くなっていきました。
転機 「なければ作ればいいんだ」 ってじっちゃが言ってた。
この業界にいるとこの言葉を聞いたことある人も多いのではないでしょうか。欲しい機能をもったものがなければ自分で作る。こーいうのがあればもっと楽できる。じゃぁ「なければ作ればいいんだ」。さて、ある日 Twitter でこんな発言をしたところ、、、
プログラマの数学の勉強会、いろんな面白い話を聞けそうやし福岡でもしてみたいけど、自分が何かしゃべるとしても、他に発表してくれる人を見つけるの無理ゲー。
&amp;mdash; けんご (@tkengo) 2015, 8月 4 
あ、ありのままにこれまで起こったことを話すぜ！このツイートをつぶやいた後にいくつかリプライが飛んできたが、気付いたら 福岡でプログラマのための数学勉強会を開催してみよう ということになっていた！なにを言っているのかわからないとおｍ・・・
開催 で、福岡になかったのでイベント作ってみました。
人気が保てれば(笑)次の開催も視野にいれているので、数学好きな人は是非遊びに来てみてください。プログラマのための数学勉強会@福岡 をよろしくお願いします。</description>
    </item>
    
    <item>
      <title>WebGLでなんか綺麗なキラキラなパーティクルの演出を作ってみた</title>
      <link>http://tkengo.github.io/blog/2015/07/15/webgl-particle-effect-we-are-xseeds/</link>
      <pubDate>Wed, 15 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2015/07/15/webgl-particle-effect-we-are-xseeds/</guid>
      <description>元々 OpenGL を使っていたことがあって 3D の基礎についてはある程度わかっていたので WebGL には本当にすんなり入ることができた。WebGL は OpenGL ES の仕様を元にしているので当然といえば当然なのですが、他の OpenGL のプラットフォームと比べて WebGL はテキストエディタとブラウザさえあれば開発環境が整うという手軽さ、さらに WebGL 界隈ではとても有名な three.js というライブラリがあるおかげで、さらに敷居が下がってる。ということで、前々から WebGL で作ってみたかった綺麗でしなやかなパーティクルの演出を作ってみました。
The XSEEDS
※ちなみに XSEEDS というのは、有志で集まったエンジニアがお酒飲みながらワイワイ開発やってる集団です。
作ってみたので、せっかくなので WebGL ってこんなことができるよ、こうやって作れるんだよ、という少し実装よりの話を紹介してみようと思います。three.js を使うの前提です。ちなみに OpenGL については以前ブログを書いたことがあって、興味のある方はそちらも読んでみてください。
独学で 1 ヶ月間 OpenGL を学んで得た基礎知識のまとめ
※シリーズ物になっていて全6回です。
はじめに こんな人が読むと面白いかも。ただの目安です。
 WebGL に興味がある 3D なとなくわかるんだけど実際にモノを作ったことがない なんでもいいから WebGL を使って簡単なものを作ってみたい  それから three.js を使うことを前提としてます。また、three.js の基礎知識の解説はしません。他に良い解説サイトがあると思います。基本的な シーン、カメラ、レンダラ、ジオメトリ、マテリアル、オブジェクト といった概念に対する知識はある前提として話が進みます。
パーティクルで文字を作る まずはこういうのを作ります。
テクスチャの生成 まず文字を構成するパーティクルオブジェクトに貼り付けるテクスチャを作ってしまいます。具体的にはこういうの。
さて、こういう画像を準備してそれをテクスチャとして読み込んでもいいのですが、同じテクスチャが張られたオブジェクトばっかり並んでいると単調でつまらないものになってしまいます(というか最初そのようにしてて「これじゃなんかつまらないな」と思っていました)。なので少しゆらぎを持たせるために canvas を使って複数個ランダムに丸い画像を描きます。
function createParticleTexture() { // 128pxのサイズのcanvasを作ります。サイズは別に128pxじゃなくても // いいですが、テクスチャとして利用するため2のべき乗のサイズにして // おいた方が良いです。(32pxとか64pxとか256pxとか) var canvas = document.</description>
    </item>
    
    <item>
      <title>果たして JavaScript で演算子オーバーロードは可能なのか</title>
      <link>http://tkengo.github.io/blog/2015/06/30/operator-overload-in-javascript/</link>
      <pubDate>Tue, 30 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2015/06/30/operator-overload-in-javascript/</guid>
      <description>果たして僕の他に誰が JavaScript で演算子オーバーロードをやりたいと思っている人がいるだろうか。
世の中のニーズは置いといて、少なくとも自分の中では欲しいと思うことがあった。JavaScript で自作のオブジェクトを作った際に、それらのオブジェクト同士の演算を定義したいことがある。Ruby や C# のもつ演算子オーバーロードの言語機能を羨ましく思いながら JavaScript でもそんなことができないのか調べて試行錯誤した結果をまとめてみようと思う。
はじまり 完全な趣味で JavaScript で行列やベクトルの演算ができる mx.js というものを作っている。mx.js では Matrix と Vector というオブジェクトが出てくるが、それら同士の足し算や引き算、掛け算を演算子を使ってやりたい、というところがモチベーションとなる。
JavaScript は言語機能として演算子オーバーロードを持っていないので、行列やベクトルのオブジェクト同士の演算を定義しようとすると普通はメソッドを定義することになる。そう、こういう風に。
var m1 = Matrix.create([ ... ]); var m2 = Matrix.create([ ... ]); // m1とm2の各要素を足し合わせる m1.add(m2);  これは一般的な、誰にでも思いつく実装でしょう。そうではなくて、もっと直感的に、まるで数値を扱うかのようにこんな風に書ければとても嬉しい。
// m1とm2の各要素を足し合わせる var m3 = m1 + m2;  これを目指して試行錯誤を繰り返していく。
オブジェクトからプリミティブへの変換 とはいえ、演算子オーバーロードがない JavaScript において、そんなことどうやって実現すればいいのか。実は JavaScript ではオブジェクトに対して + や - のような二項演算子を適用した場合、左オペランドから右オペランドの順に valueOf というオブジェクトをプリミティブ型に変換するためのメソッドが暗黙的に呼び出される。つまりはこういうこと。
Matrix.prototype.valueOf = function() { return this.rows + &amp;quot; x &amp;quot; + this.</description>
    </item>
    
    <item>
      <title>PHP カンファレンス福岡に行ってきたばい</title>
      <link>http://tkengo.github.io/blog/2015/06/29/php-conference-in-fukuoka/</link>
      <pubDate>Mon, 29 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2015/06/29/php-conference-in-fukuoka/</guid>
      <description>PHP カンファレンス福岡 に参加してきたけん、感想ブログ書くったい！
「ブログを書くまでが PHP カンファレンス福岡」ってみんなが言いよったろうもん？ブログ書くばい、ブログ。
PHP イベントで過去最大の規模？ 当日はイベント開始 10 時ぎりぎりに会場について、会場はもうたくさんの人でガヤガヤしとった。
運営の人に聞いたっちゃけど、一般参加者、運営、スポンサー、スピーカー、を全部あわせたら、200人ぐらいおったらしい。すごさー。これだけの規模のカンファレンスを開催するのは、準備が大変やったろうと思う。良い話もいっぱい聞けて、懇親会も豪華で、全体的にめちゃくちゃ楽しかったし、本当に運営のみなさんには感謝しかない。
貴重なセッション 席に座ってごにょごにょしよったら、開会の挨拶もほどほどに PHP カンファレンス福岡がはじまった。僕が聞いたセッションは以下の 7 つ。
 基調講演「全てを結ぶ力」 YOUR.Sunday 10年超えるサービスのphpバージョンを4から最新にする話 CakePHP3ウォークスルー PHPで学ぶ仮想マシン型正規表現エンジンの仕組み インフラエンジニアからレガシーPHPへのレイヤーアップ とある事業の脱レガシー 〜技術的負債を取り戻すプロジェクトの物語〜  基調講演の登壇者の郡山さんという方、このセッションの内容的には Hypertext の話で、セッションの内容もそうなんやけど、しゃべりの方もめちゃくちゃうまくて面白くてすーっと彼の世界に引き込まれてしまった。Hypertext の歴史的な話から始まり、インターネットとは、Web とは、という壮大な話。とても良かった。
それから基調講演のすぐ後の YOUR.Sunday というセッション、こっちも郡山さんのセッションなんやけど、これもすごく面白かった。BEAR.Sunday というフレームワークの作者なので、フレームワーク開発をしていくなかで得た知見などを共有してくれた。なぜフレームワークを作るのか？あたりの話は参考になった。
3 と 6 はペパボの人のセッション。ふたりともレガシー改善系の話で、自分も元ペパボやったけん応援（と少しのひやかしも込めて）しっかり聞かせてもらいました。元々自分もペパボにおったし、レガシーシステムの改善も同僚と一緒に進んでやってきたけん、システムの中の話とかある程度わかったし、だいたいどの辺で苦労しとるんやなーというのも想像ついたんやけど、やっぱり腐らんで常に改善していこうっていう努力を続けよる彼らはすげーなーって関心した。笑いも各所に散りばめてあって、おもしろかったです。お疲れ様！
4 は CakePHP 3 になってなんが変わったと？という話。モデル周りの話しかなったけど、O/Rマッパ周りがかなり便利になっとった。CakePHP 2 の頃はモデルの find 呼んだら、クエリが全部実行されてその結果が配列になって返ってくるっていう仕様やったけど、CakePHP 3 になると参照される時にはじめてクエリが実行されるようになったらしいね。これかなり良い改善なのでは！
5 はあんまり PHP 関係なかったけど、正規表現周りは昔から興味あったけん面白かった。前に決定性有限オートマトンを使った正規表現の実装の勉強をしたことがあって、今回のは VM を使った正規表現の実装の話で、なるほどこんなやり方もあるったいねー、という新しい引き出しが増えたのが嬉しかった。
全体的な印象としてはレガシー改善系が多かったみたい。自分が聞きよったセッションの裏セッションでもいくつか秘伝のタレとかレガシーとかをネタにした話があったらしい。
LT は全部おもしろかった。こういうとこで LT する人は場数踏んどるっちゃろうな、笑いが止まらん LT やった。タメになる話も面白い話もいっぱいあって最高のカンファレンスでした。
懇親会 ビュッフェ形式。ビールいっぱいあるし、料理はどれでも美味しいし、楽しい時間は過ごせたし、良い懇親会やった。写真とかなんも撮らんかったけん、画像がなくて殺風景な感想ブログになってしまった。
来年に向けて 主催の人が「来年も期待して！」みたいなこと言いよったけん、また開かれるっちゃない！？</description>
    </item>
    
    <item>
      <title>Hello World in OpenGL!</title>
      <link>http://tkengo.github.io/blog/2015/02/01/opengl-es-2-2d-knowledge-6/</link>
      <pubDate>Sun, 01 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2015/02/01/opengl-es-2-2d-knowledge-6/</guid>
      <description>OpenGL 基礎シリーズ の第 6 回です。
Hello World in OpenGL! いよいよこのシリーズもこれで最後。実際に動作するソースコードを紹介しながらこれまで得た知識と照らしあわせていきたい。記事の最初にも書いたとおりサンプルコードは Android になるけど、Android 固有の部分を除いて OpenGL の部分に関しては他のプラットフォームでも似たような API は提供されているので (若干仕様が異なる API もあるけど) これまでに蓄えられてきた基礎知識が活きていれば Android 以外でも「こんな風に書けばいいのかな」という想像が簡単にできると思う。
ということで早速コードを紹介しつつ解説を。
MainActivity.java public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); GameSurfaceView view = new GameSurfaceView(this); setContentView(view); } }  まずはアクティビティ。GameSurfaceView という独自のビューを生成してアクティビティに配置している。
GameSurfaceView.java public class GameSurfaceView extends GLSurfaceView { private static final int OPENGL_ES_VERSION = 2; public GameSurfaceView(Context context) { super(context); setEGLContextClientVersion(OPENGL_ES_VERSION); setRenderer(new GameRenderer()); setRenderMode(RENDERMODE_CONTINUOUSLY); } }  次に GameSurfaceView。Android で OpenGL を使った描画をするためには GLSurfaceView というビューを継承したカスタムビューを作る。そのカスタムビューの中で独自のレンダラーをセットすることで、そのレンダラーの中で実装された関数が呼び出され、OpenGL とのやり取りができるようになる。</description>
    </item>
    
    <item>
      <title>テクスチャマッピング</title>
      <link>http://tkengo.github.io/blog/2015/01/27/opengl-es-2-2d-knowledge-5/</link>
      <pubDate>Tue, 27 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2015/01/27/opengl-es-2-2d-knowledge-5/</guid>
      <description>OpenGL 基礎シリーズ の第 5 回です。
テクスチャマッピング 実は OpenGL では jpg や png といった画像の類をそのままフレームバッファに描画することはできないし、そもそも画像読み込み系の関数すら持ち合わせていない困ったチャンなのだ。この時点で画像描画に関しては詰んでそうだけど、そんなことはなくって (そんなことがあったら今頃 OpenGL なんて誰も使っていない) ちゃんと方法がある。それがテクスチャだ。
テクスチャという単語は聞いたことがあるかもしれないし「テクスチャを貼り付ける」だとか「画像を貼り付ける」だとかいうのは良く言われる。2D でゲームを作る場合はテクスチャを画像と同じ大きさの四角形のポリゴンに対して貼り付けることで画像を、例えばキャラクターの画像など画面上に表示させることができる。でも一体テクスチャとはどういうものなのか、どういう原理で画像をディスプレイに表示しているんだろうか。それがわかれば OpenGL で自由に画像を表示できるようになる。エフェクトをつけるのだって自由自在。
あなたは既にテクスチャのある世界への一歩を踏み出している。
テクスチャの準備 画像を表示するためにテクスチャを使うならば兎にも角にも、表示したい画像の用意が必要になる。ここでは Android Studio で新規プロジェクトを作った時に最初から同梱されているあの有名なドロイド君を使って説明を進めてみようと思う。いつもありがとう、ドロイド君。画像に困ったときは君だね☆
さて、ドロイド君に登場してもらったところで実際にこのドロイド君をテクスチャとして利用するためには、いろいろと前準備をやっとかないといけない。もっとも単純には GPU に対して以下のような要求を送ってやることになる。
 テクスチャが欲しいので新しく作ってちょうだい！ ありがとう。じゃぁこれからこのテクスチャに対していろいろ操作するからね フィルタリングの設定はこれでお願い 画像データをそっちに送るのでよろしく〜  それぞれの要求には専用の API が用意されているのでそれを呼び出すだけでいいので簡単なのだ。猫でもわかる OpenGL！
※マルチテクスチャを利用する場合はもう少し手順が増えることになるけど、それにもちゃんと専用の API が用意されている。とりあえず最低限これだけ把握できていれば問題はない。
テクスチャの生成 画像を読み込んでそれをテクスチャに割り当てるためには GPU に対して新しいテクスチャを生成するよう要求しないといけない。Android には glGenTextures というメソッドがあり、それを使って新しいテクスチャを生成する。テクスチャが生成されると整数型の数字 (1 とか 2 とか) を受け取り、それがテクスチャの ID となる。ちなみに Android では一気に複数のテクスチャの生成を要求することができる。
生成したテクスチャのバインド テクスチャを生成したらそのテクスチャをバインドする必要がある。テクスチャをバインドすることで、そのバインドされたテクスチャに対して、テクスチャパラメータの設定をしたり画像データを送信したりすることができるようになる。OpenGL のテクスチャ関連のメソッドのリファレンスを確認すればわかるけど、それらのメソッドの引数にはテクスチャ ID がない。つまりテクスチャに対する操作は、メソッドの引数でテクスチャ ID を指定するのではなく、OpenGL 側でテクスチャの状態を持っていて現在バインドされているテクスチャに対して行われるということになる。
テクスチャのバインドは glBindTexture というメソッドがあり、引数としてテクスチャ生成時に受け取ったテクスチャの ID を渡す。</description>
    </item>
    
    <item>
      <title>ラスタライザの画素生成と線形補間</title>
      <link>http://tkengo.github.io/blog/2015/01/17/opengl-es-2-2d-knowledge-4/</link>
      <pubDate>Sat, 17 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2015/01/17/opengl-es-2-2d-knowledge-4/</guid>
      <description>OpenGL 基礎シリーズ の第 4 回です。
ビューポート変換 ラスタライザの話をするまえにもひとつ変換についての話を。バーテックスシェーダによって長い長い座標系変換の旅 (いやテキストだと長いけど GPU での演算は一瞬で終わるからね。一瞬で) をしてきた頂点達にとって最後の変換過程が残っている。それがビューポート変換というやつだ。
「とうとう現れたか、ビューポート変換め！」 『 グヘヘヘよく来たな頂点ども。 』 「臆することはない、ヤツは 座標系変換四天王の中でも最弱 。」
ということで簡単です。
バーテックスシェーダで最終的に変換されたクリッピング座標系は xyz 座標がそれぞれ -1 〜 1 の範囲に正規化された座標系だったけど、それを実際にオブジェクトを描画するディスプレイのサイズの座標に変換する。その際、次のラスタライズの処理に繋げるために xy 成分だけ取り出して平面にしておく。これをウィンドウ座標系といって、左下が原点 (0, 0) になる。たとえば描画先のディスプレイのサイズが 800 x 600 だった場合はこんな感じ。
Android では以下のメソッドを呼び出すことでビューポート変換での幅や高さの設定ができる。
GLES20.glViewport(ディスプレイ左下のx座標, ディスプレイ左下のy座標, ディスプレイの幅, ディスプレイの高さ);  ところで残った z 座標はどこへ行くかというと、ポリゴンが重なっていた場合にその前後の位置関係を把握して重なりを制御するためにデプステストという工程がフラグメントシェーダの後にあるんだけど、そこで使われるために別途バッファに保存される。デプステストについては最初の目次に書いてないのでこのブログに出てくる予定はないけど、時間があればその仕組みを解説する記事をかいてみようかな。
ラスタライズ それでは本題のラスタライズの話。バーテックスシェーダとビューポート変換によって最終的な平面上での頂点の位置が計算されたことで最終的なポリゴンの形もここで確定された。次はこのポリゴン達がディスプレイ上の (正確にはフレームバッファー上の) どのピクセルに描画されるのかを求める必要がある。前にも書いたけど、ラスタライズは描画するピクセルつまり画素を生成することを言い、生成された画素のことをフラグメントと言う。ここではどのようにラスタライズが行われ、そしてそれらのピクセルがどのようにフラグメントシェーダに渡されるのかを詳しく見てみる。この辺の話は 2D を扱いたい場合でも 3D を扱いたい場合でも変わりはない。
ラスタライズには以下の 3 つのプロセスがある。
 ポリゴンの裏表面の判別 表面のポリゴンが覆っているピクセルのフラグメント生成 バーテックスシェーダから渡された値の線形補間  ポリゴンの裏表面の判別は頂点情報の話をした時にも書いたとおり、頂点インデックスを指定する順番によって変わる。裏表の判別が終わったら、次はフラグメントの生成に移る。ここでもしカリングが有効になっていれば裏面を向いたポリゴンは無視され、表面を向いているポリゴンが覆っているフレームバッファー上のフラグメントだけが生成される。カリングが無効になっていれば裏面ポリゴンも同様に処理される。そして最後にバーテックスシェーダから渡ってきた値 (たとえば頂点座標や法線情報、色情報、など) を生成されたフラグメント毎に線形補間して、フラグメントと一緒にフラグメントシェーダに渡してあげるといった流れになる。
フラグメント生成方法 OpenGL においてフレームバッファのある特定のピクセルのフラグメントが生成されるかどうかは、そのピクセルの中心がポリゴンの内側に位置しているかどうかによって決まる。以下の図は、各矩形が画面上の 1 ピクセルを表しており、その中にある赤い点がそのピクセルの中心点、そして赤い枠線がポリゴンの形になっている。中心点である赤い点が赤枠の内側にあるピクセルについては紫色で塗りつぶされており、これがラスタライズ処理によって生成されるフラグメントになる。そしてそれら 1 つ 1 つがすべてフラグメントシェーダに渡される。</description>
    </item>
    
    <item>
      <title>バーテックスシェーダによる座標系変換</title>
      <link>http://tkengo.github.io/blog/2015/01/10/opengl-es-2-2d-knowledge-3/</link>
      <pubDate>Sat, 10 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2015/01/10/opengl-es-2-2d-knowledge-3/</guid>
      <description>OpenGL 基礎シリーズの第 3 回です。
座標変換 プリミティブの描画には頂点座標が必要なのはわかった。だって、座標情報がないとそもそもどこに描画していいのかがわからないんだから。でもよく考えてみて欲しい、この座標情報って どの座標系における座標 なんだろう？それって最初に出てきた右手座標系とかいう座標系じゃないの？うーん、そうなんだけどここで話したいのはそういうことじゃない。それじゃディスプレイ上の座標に配置してるに決まってるよ！いやいやそんなことはない。私達は今、OpenGL 上で 3D 空間を扱っている。でも現実のディスプレイは 2D の平面。はい、これらはそもそも次元が違う。
最初にバーテックスシェーダの概要を書いた時に座標系の変換過程を図に示したのを思い出してみると、3D 空間を扱うためには少なくとも 4 つの座標系があった。最初に頂点座標を配置した座標系から最終的にはクリッピング座標系という座標系に変換していく必要があり、それこそがバーテックスシェーダの役割である。そして前回の記事で頂点座標を定義した時、その (x, y, z) で表される頂点座標は、実はローカル座標系における座標を指定していたのだ！ドヤァー
突然ドヤァーされても意味わからないと思うので詳細を見てみよう。
変換行列 では実際バーテックスシェーダで座標系の変換をするっていっても、それってどうやればいいのか。答えは行列です。行列というと高校数学程度の知識が必要になりそうだけど、行列の生成や演算など面倒なことは全て CPU や GPU がやってくれる。私達に必要なのは、どういう変換行列の種類があって、それをどのように組み合わせて利用するのか、ということだけなので「自分理系じゃなかったんだけど&amp;hellip;」という人でも心配はない。便利な世の中〜。
とはいえ、実際にどういうものかぐらいは頭に置いておいたほうがイメージしやすいので、絵に書いてみると行列ってこういうもの。いろいろ難しそうな表現があるけど、わからないならわからないで深く理解しなくても大丈夫な領域ではあるので不安にならずに先に進んで大丈夫だと思う。もし知りたければ適当にググれば解説サイトはいっぱい出てくる。
※頂点座標は (x, y, z) の 3 次元だったけど図の青枠で囲ってある頂点座標は 4 つになっている。最後の 1 ってなんだろう？これは頂点座標と変換行列の演算を単純にするために導入される 同次座標系 という新しい概念になるのだけど、この話を詳しくしだすと OpenGL から飛び出してしまうのでここでは割愛する。最後の 1 はよくある おまじない だ。。 。
では、前提知識をつけたところで実際にどういう風に座標系が変換されていくのかを見ていく。長い長い座標系変換への旅へ出発。
ワールド座標変換 まずはワールド座標変換。ジョジョじゃないよ。
 Picture by Hay Kranen / CC-BY
ポリゴンが組み合わさって何かしらの形を作っているものは「モデル」と呼ばれ、通常は大量のポリゴンを組み合わせて「人のモデル」とか「木のモデル」とか複雑なものが定義される。ここに表示しているのは ユタ・ティーポット と言って、これもモデルの 1 つで CG の分野では有名なモデル。こういったモデルはそのモデル専用のローカル座標を持っており、通常は頂点座標はこのローカル座標系の座標を表している。
そしてワールド座標変換とは、そういったローカル座標で定義されている各モデルを OpenGL 唯一の世界の座標に配置していく作業のことを言う。以下の図では立方体のモデル、三角柱のモデル、四角形のモデル、をそれぞれローカル座標系からワールド座標系へ変換している。こうしてみるとまるで OpenGL の世界の神様になったみたい。ワールド座標変換に使われる行列は</description>
    </item>
    
    <item>
      <title>頂点情報とプリミティブ</title>
      <link>http://tkengo.github.io/blog/2015/01/03/opengl-es-2-2d-knowledge-2/</link>
      <pubDate>Sat, 03 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2015/01/03/opengl-es-2-2d-knowledge-2/</guid>
      <description>OpenGL 基礎シリーズの第 2 回です。
OpenGL の座標系 まず頂点の話をする前に前提として知っておかなければならない座標系の話がある。私達が 3D の世界を扱う時は 右手座標系 と 左手座標系 という 2 つの座標系が存在する。それぞれの違いは z 軸の向き。
 右手座標系は z 軸の手前の方がプラス、z 軸の奥のほうがマイナス 左手座標系は z 軸の手前の方がマイナス、z 軸の奥のほうがプラス  3D の座標を扱う時はこの座標系のどちらかを採用しており、我らが OpenGL ではポリゴンを配置する時の座標系は右手座標系を使う。この右手座標系は数学の世界で使われている座標系で OpenGL がこれを採用したのはそれが理由と言われている。(※ちなみにご存知 Windows の DirectX 3D は標準では左手座標系を採用している)
2D を扱うにあたって遠近感を出すために z 軸を意識することはあんまりないけど、描画する要素の重なりを制御するために使うことはよくある。ゲームなどで画像を重ねて描画するにあたっては z 軸の奥の方がプラスになってる方がわかりやすく、右手座標系のように z 軸の手前の方がプラスになっているのは違和感がある人が多いかもしれないけど、自分の感覚と違ってもそこだけは間違えないようにしないと、背景の方がキャラクターより前にきてしまって、あれ？なんでキャラクターいないの？という風に思った通りの描画が出来なくなってしまうので要注意。
※ちなみになんで右手と左手というんだろうか？それは、親指の先を x 軸プラス方向、人差し指の先を y 軸プラス方向、中指の先を z 軸プラス方向と思って、実際の座標系の軸を手を使って形作ってみるとわかる。右手でそれをすると中指が自分の方向を向いて、左手でそれをすると中指が向こう側を向くはずだ。こういう単純でどうでもいいことでも、理由がわかって納得できると面白いですよね？
プリミティブ もう何度も言ってる気がするけど OpenGL では 3D の頂点情報 (x, y, z) を定義して、それを GPU に転送することで描画を行う。それによって描画されるものを プリミティブ と言って、OpenGL の世界で描画できる最小単位のことを言う。また新しい言葉が出てきた！ってひるまないひるまない。ただ単に言葉の定義だけ。で、プリミティブには以下の 3 種類がある。</description>
    </item>
    
    <item>
      <title>OpenGL が世界を描画する仕組み</title>
      <link>http://tkengo.github.io/blog/2014/12/27/opengl-es-2-2d-knowledge-1/</link>
      <pubDate>Sat, 27 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2014/12/27/opengl-es-2-2d-knowledge-1/</guid>
      <description>OpenGL 基礎シリーズの第 1 回です。
ビューイングパイプライン OpenGL が世界を描画するっていうタイトルだけでワクワクするなら、あなたはもう OpenGL の、いや、このブログの虜です。というのはおいといて、OpenGL で描画すると一言で言ってもその描画フローの中には大量の計算処理が含まれおり、そのフローをひと通り全て通り超えてこそ初めて画面に何か描画される。いわゆるパイプラインと呼ばれる処理の流れがあり、それはおおまかには以下のようになっている。細かくは他にもやってることはあるし厳密には実際と異なる部分もあるけど、これくらい抑えておけば基本はわかると思う。
ちなみに赤い部分は自分でプログラミングする必要がある。青い部分は設定値さえこちらから与えてやれば後は OpenGL が内部でよろしくやってくれる。
 ふー、ただ単に 1 枚の画像を描画するだけでもこれだけのフローがあって、そして突然わけもわからない単語が大量に出てくるもんだからブラウザを「そっと閉じる」人がいるかもしれないけど、まあ正しい反応かもしれない。そういう人達は素直に Cocos2d-x とか Unity とかでゲームを作るほうが幸せを感じられると思う。Cocos2d-x や Unity などの便利ツールは実は中でこんなことをやってるのだ。恩恵は計り知れない。ありがとう Cocos2d-x！ありがとう Unity！
さて、フローの各部分の詳細は別途記事にするとして大事な部分だけの簡単な概要だけをまずはどうぞ。
アプリ側でデータの準備 OpenGL では、どこに何を描画するかは頂点座標によって決まるので、頂点座標は必須で準備する必要がある。そして、描画する物体に対して移動・回転・拡大・縮小などの操作を加える場合には変換行列も必要になる。さらに、画像を表示したい場合はテクスチャの ID と UV 座標も必要になる。私達開発者は、こういった各種データをアプリケーション側で準備して、OpenGL が提供している API を介してデータを GPU に転送する。
いやしかし、頂点座標とか変換行列とか UV 座標とかわけのわからない単語がまた出てきて、突然のウルトラヴァイオレット！イミフ！！！ですが、でも大丈夫！ちゃんと別の記事で詳しく触れていくので。ちなみに UV はウルトラヴァイオレットじゃないよ。
シェーダ そしてまたすぐにわけのわからないシェーダとかいう単語が出てくる。シェーダって何だろう？Wikipedia によると
シェーダ（英: shader）とは、3次元コンピュータグラフィックスにおいて、シェーディング（陰影処理）を行うコンピュータプログラムのこと。「shade」とは「次第に変化させる」「陰影・グラデーションを付ける」という意味で、「shader」は頂点色やピクセル色などを次々に変化させるもの（より具体的に、狭義の意味で言えば関数）を意味する。 「はいはい、イミフイミフ」
いつも思うけど Wikipedia ってわざと難しく書いてない？さて、まず 2D だったら x 座標と y 座標を指定して描画するメソッドを呼び出せば簡単に画像でも線でも表示できた。できたんだけど、じゃぁ 3D はどうかっていうとそう簡単にはいかなくって、別途 3D 空間を描画するためのプログラムが必要になってくる。その描画するプログラムのことをシェーダと言って、シェーダにはいくつか種類があるんだけどとにかく OpenGL の場合、このシェーダプログラムがないといくら描画メソッドを呼び出しても画面には何も表示されない。
さて、そしてここから重要。OpenGL ES 1.x の頃は OpenGL に組み込みのシェーダが存在しており固定機能パイプラインとかって呼ばれてたけど、それに対して OpenGL ES 2.</description>
    </item>
    
    <item>
      <title>独学で 1 ヶ月間 OpenGL を学んで得た基礎知識のまとめ ~ 2D 編 ~</title>
      <link>http://tkengo.github.io/blog/2014/12/20/opengl-es-2-2d-knowledge-0/</link>
      <pubDate>Sat, 20 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2014/12/20/opengl-es-2-2d-knowledge-0/</guid>
      <description>OpenGL。その単語の響きだけで素晴らしく魅力的に思える 3D コンピューターグラフィックスライブラリは、これまで何人もの駆け出しゲームプログラマーに幾度と無く挫折を味わわせてきた。「ゲーム作るならやっぱり高速に描画できる OpenGL でしょ。でも自分が作るゲームに 3D はいらないし、しかも難しそうだし、別に 2D 描画だけできればいいや」 と、軽い気持ちで手を出したのが運の尽き、世の中そんなに甘くはなかった。OpenGL というその難攻不落城は私達の進む道を阻むように高々とそびえ立っている。
OpenGL がコレほどまでに取っ付きにくいのは 気軽に Hello World できない からなんじゃないかと思う。OpenGL の場合だとそれは何かしら 1 つの図形を表示することにあたるのかな。でもたったそれだけなのに、覚えることが山ほどありすぎて全然本題にたどり着くことができないし、OpenGL には OpenGL ならではの複雑さがある。巷にあふれているサンプルコードについて「なぜそう書けばこう動くのか」という仕組みやその意味を、コードを読んだだけでしっかりと理解できる人はどれくらいいるだろうか。英語でも何でもとりあえず頑張って読んでみて、そういうところからソースコードをコピペして、コンパイルして、やったー動いたー、ってなったとしても、その先には闇しか見えない。基本を理解してないと応用はできないのです。でもね！それは仕方ないことなのです、たぶん。何を始めるにも基礎知識は必要になってくる。逆に言えば基礎がしっかりしていればあとはなんでもできる。
ということで、こういうインターネット上の情報はいくらあっても損はしないので、OpenGL で 2D を扱うために 3D の基礎を説明して、んで OpenGL 使うんだったら基礎おさえとけば 2D でも 3D でも難易度そんなに変わらなくね？ってとこに気付けたら、その知識を元にプログラミングができるところまでブログの記事にまとめてみようと思う。ちなみに本とかで体系的に勉強したわけではないので、間違いがあれば突っ込んでくれると喜びます。
前提 さて、前置きが少し長くなったけど、今回の記事の対象となるものは Android 向けの OpenGL ES 2.0 です。知ってる人もいるかもしれないけど OpenGL ES の 1.0 と 2.0 は 後方互換性がない別物になってる ので 1.0 と間違ってこの記事を読み進めるようなことがあったら、の〜みそぷ〜ですよ。今後、記事内で OpenGL というと OpenGL ES 2.0 のことを指すことにする。で、Android 向けなので記事中のソースコードも Android のソースコード、つまり Java。
ただ、基礎知識部分は OpenGL ES 2.0 に限らず 3D 表現を行う上で共通の部分が多く、2.</description>
    </item>
    
    <item>
      <title>Serializable なクラスを Proguard で難読化する時の話</title>
      <link>http://tkengo.github.io/blog/2014/11/05/serializable-class-on-proguard/</link>
      <pubDate>Wed, 05 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2014/11/05/serializable-class-on-proguard/</guid>
      <description>Android のアプリを開発する際にソースコードに難読化を施すために Proguard を使っていて Serializable なクラスが難読化対象になっている場合に、思いもよらないバグが発生してしまうことがあります。先日そのバグに遭遇してしまい、原因究明にほぼ丸1日かかってしまいました。
発生事象  新機能を追加したアプリをバージョンを1つあげて Google Play ストアに登録した。 アプリをアップデートしてから起動する。 設定画面を開くと設定情報が消えてる。  こんな感じでした。アップデートに含まれる改修では、設定画面はまったくいじってなかったのでなんで突然こんなことが起きるのか謎。ちなみに設定ファイルは
 設定情報は Serializable を implements したクラスをシリアライズしてファイルシステムに書き出してある そのクラスは Eclipse の機能を使って serialVersionUID を自動生成している 読み込みは ObjectInputStream を使ってファイルを読み込んで元のクラスにキャストして使っている  という風にファイルに保存して管理していました。
原因 結論としては Proguard で難読化された結果、マッピング先のクラスが変わっており serialVersionUID が正しく取得できておらず InvalidClassException が発生していたのが要因でした。
以下では手順を追って説明していきます。
設定クラスの定義 たとえば Configuration クラスがファイルの保存・読み込みを行うクラスとして、以下のように実装されています。(当然この他にも各値のゲッターの実装もあるとは思いますが、簡略化のためにここでは省略します)
public class Configuration implements Serializable { private static final long serialVersionUID = -2203743867770177617L; private String mName; private int mAge; private int mSex; public LocalTargetProfile(String name, int age, int sex) { mName = name; mAge = age; mSex = sex; } }  そして Application クラスを継承した MainApplication クラスの中で、この Configuration クラスの読み書きを行うメソッドが以下のように実装されています。(簡略化のために例外処理やファイナライズ処理は省略します)</description>
    </item>
    
    <item>
      <title>謎の単位 &#34;dp&#34; (Density-independent Pixel) にせまる。あと drawable の話とか in Android</title>
      <link>http://tkengo.github.io/blog/2014/10/18/android-dp/</link>
      <pubDate>Sat, 18 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2014/10/18/android-dp/</guid>
      <description>Android 端末のディスプレイってめちゃくちゃいろんなサイズがあって Android を始めたばかりの自分にはそれぞれに最適なレイアウトや画像をどうやって作ればいいのかって全然わかっていませんでした。それに Android ではサイズの単位に px (pixel) じゃなくて dp (density-independent pixel) を使うらしいってことは聞いたことあるけど、そもそも dp ってなんなの？という感じだし。わからないまま放置しておくのも良くないので色々調べてみたらだんだんとわかってきたので、忘れない内にまとめておこうかと思う。既にネットにある記事の二番煎じになるかもしれないけど、インプットしたものを体系的にまとめて知識を自分のものにするためにも再まとめ的なものを書く。
用語定義 自分がこの話題について調べ始めた時、自分の中で Android 用の各用語の定義がはっきりしておらず意味もあまりわかってなかったので、いろんなサイトを見ても全然理解が進みませんでした。この辺の用語の意味がわかってきてからなんとなく理解が進み始めたので、まずは各用語がどういう意味なのかをはっきりさせておきます。
解像度 画面のピクセル数のことを表します。例えば 480 x 800 とか 720 x 1280 とかいうやつですね。解像度の単位は px (pixel) です。いくつかの実際の機種の解像度をみてみると
   デバイス名 解像度 備考     GALAXY S4 SC-04E 1080px x 1920px    Xperia Tablet Z SO-03E 1200px x 1920px タブレット   GALAXY S2 SC-02C 480px x 800px     てな感じで、各機種毎に解像度は違います。ただ、解像度は実際の画面の大きさが何インチあるかとは無関係にディスプレイのピクセル数を表していますので、単純に解像度が大きければ画面サイズも大きくなるのかというと、そうではありません。スマホよりタブレットの方が物理的に大きいのは直感的にわかると思いますが、GALAXY S4 より Xperia Tablet Z の解像度の方が劇的に大きいかというとそうでもなく、横幅が少し広いくらいの解像度になっています。</description>
    </item>
    
    <item>
      <title>超えられない英語の壁を超えるための方法の1つ ITEigo@Fukuoka</title>
      <link>http://tkengo.github.io/blog/2014/08/28/iteigo-at-fukuoka-for-the-first-time/</link>
      <pubDate>Thu, 28 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2014/08/28/iteigo-at-fukuoka-for-the-first-time/</guid>
      <description>ITEigo@Fukuoka という、参加者全員が何かしら IT に関しての話を英語でプレゼンして英語で質疑応答するというイベントを福岡で開催しました。
元々は @cakephper さんが東京で開催していたイベントで、自分も参加したいと思いつつ九州に住んでいるのでわざわざ東京までいくのも大変でしたので当時は見守ってだけいました。んで、そのことを思い出して何気なく Twitter でつぶやいてたら、主催者がその声を拾ってくれて福岡での開催となりました。
福岡開催は今回が初めてです。基本的には本家のルールに則って、こんな感じのルールでやりました。
 参加者全員が IT に関する発表をする(話題は何でもいいです) 自分のサービスを紹介したり 自己紹介したり 海外のニュースを紹介したり 最近興味あることを話したり とにかく英語でプレゼンするならなんでもOK 発表時間は5分(英語で発表) 質疑応答は3分(英語で質疑応答)  様子です LINE Fukuoka のオフィスで開催されました。 プレゼンの様子です。全部英語でしゃべってます。 質疑応答も英語です。そして終わったら雑談を少々。 ※写真を見てわかるかもしれませんが、みんなビール飲みながらやっています。飲んだほうがしゃべりやすいです(笑)
資料 ITEigo@Fukuoka で使った資料は SpeakerDeck にあげました。
  今後について 思った以上に盛り上がったし、周りの反応も上々なのでとりあえず第二回も開催してみようかなーと思っています。
気になる方は Twitter のハッシュタグ #ITEigo あたりを眺めてみてください。</description>
    </item>
    
    <item>
      <title>Chrome Extension の CI が出来るようになるまで(準備編)</title>
      <link>http://tkengo.github.io/blog/2014/07/22/ci-for-chrome-extensions2/</link>
      <pubDate>Tue, 22 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2014/07/22/ci-for-chrome-extensions2/</guid>
      <description>個人的に趣味で Chrome Extension の開発をしていますが、最近いろいろとノウハウも溜まってきたので Chrome Extension の CI について少しまとめてみるシリーズです。
前回の記事はこちら。
Chrome Extension の CI が出来るようになるまで(導入編)
目次  はじめに Chrome Extension のテストを書く  何をテストするのか テストフレームワーク Jasmine のインストール Jasmine でテストを書いてみる JavaScript APIs をモックする HTML Fixture を読み込む  Chrome Extension のテストを実行する  テストランナー Karma Karma のインストール Karma でテストを実行する ファイルの変更を監視する コードカバレッジを出力する HTML Fixture を読み込む  Chrome Extension を CI する  CI サービス Wercker Wercker にリポジトリを登録する wercker.yml Step の作り方 バッヂ   Chrome Extension のテストを実行する Chrome Extension でテストを書くことにも慣れてくると、次はそのテストの実行をなんとか簡略化したくなってきます。前回も説明したように SpecRunner.</description>
    </item>
    
    <item>
      <title>Chrome Extension の CI が出来るようになるまで(導入編)</title>
      <link>http://tkengo.github.io/blog/2014/06/22/ci-for-chrome-extensions1/</link>
      <pubDate>Sun, 22 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2014/06/22/ci-for-chrome-extensions1/</guid>
      <description>個人的に趣味で Chrome Extension の開発をしていますが、最近いろいろとノウハウも溜まってきたので Chrome Extension の CI について少しまとめてみようと思います。
目次  はじめに Chrome Extension のテストを書く  何をテストするのか テストフレームワーク Jasmine のインストール Jasmine でテストを書いてみる JavaScript APIs をモックする HTML Fixture を読み込む  Chrome Extension のテストを実行する  テストランナー Karma Karma のインストール Karma でテストを実行する ファイルの変更を監視する コードカバレッジを出力する HTML Fixture を読み込む  Chrome Extension を CI する  CI サービス Wercker Wercker にリポジトリを登録する wercker.yml Step の作り方 バッヂ   はじめに Google Chrome を vim のようにキーボードで操作できるようにする Hometype という Chrome Extension を作っていますが、この記事は Hometype でやってきたことベースに話を展開していきます。</description>
    </item>
    
    <item>
      <title>Weechat内でマウスを操作せずにURLを開けるプラグイン欲しくありませんか？</title>
      <link>http://tkengo.github.io/blog/2014/04/15/introduction-weechat-url-hinter/</link>
      <pubDate>Tue, 15 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2014/04/15/introduction-weechat-url-hinter/</guid>
      <description>CUI で動作する IRC クライアントの 1 つに weechat があります。ペパボでは業務に IRC を利用しており、会話中によく URL が貼られたり BOT の通知で URL が貼られたりして、それなりの頻度でチャンネルの中に URL が出現します。Mac であれば Command を押しながら URL をダブルクリックするとブラウザで開けるのですが、その際に一度キーボードから手を離す必要があって面倒臭かったので Hometype(紹介記事) のヒントモードをヒントに weechat のプラグインを作ってみました。
前提  Mac OS X でのみ有効なプラグインです。 ruby で書かれているので ruby を有効にしてコンパイルされている必要があります。brew でインストールするのであれば --with-ruby オプション付きでコンパイルされている必要があります。  インストール weechat の公式スクリプトとしての登録はされてないので、リポジトリから直接ファイルをダウンロードしてきてください。
$ curl -o ~/.weechat/ruby/autoload/url_hinter.rb https://raw.githubusercontent.com/tkengo/weechat-url-hinter/master/weechat-url-hinter.rb  ダウンロードが終わったら weechat を再起動してください。
使い方 URL が表示されているバッファ上で
/url_hinter  とコマンドを打ってみてください。通常はこのようなバッファーですが
コマンドを実行すると
のように URL だけハイライトされて、先頭に 1 文字のキーが表示されていることがわかります。(1 文字で収まらない数の URL が画面上にある場合は 2 文字になります)</description>
    </item>
    
    <item>
      <title>リモートリポジトリの master は破壊するべからず。git push できないようにしてみよう</title>
      <link>http://tkengo.github.io/blog/2014/03/10/reject-git-push-to-remote/</link>
      <pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2014/03/10/reject-git-push-to-remote/</guid>
      <description>会社で github で管理しているリポジトリがあるのですが、なるべくなら master に直接 push するのは避けたいものです(最近のフローとしては pull request から master にマージされることが多いですよね)。
最初は github 上に git のフックを仕掛けて master に push しようとする要求があればはじくようにしたいと思ってたのですが github ではそういったことは出来ないようなので、サーバー側ではなくローカル側にフックを仕掛けて master に push できないようにしてみました。
デザイナなど黒い画面が苦手な人でも最低限のコマンドで実現出来るように、インストール用のスクリプトを書いて gist に公開 してみました。
フックのインストール ターミナルから以下のコマンドを実行すればOKです。
$ curl -s https://gist.githubusercontent.com/tkengo/9320008/raw/f19ce447307ce0f562d5b3ca834d09d22662b7f2/gistfile1.sh | sh OK, all set. All you need to do is that executing &amp;quot;git init&amp;quot; in your existing git project directory.  OK, all set と表示されれば正常に完了しています。これだけ。フックは ~/.git_template/hooks/pre-push にインストールされます。
新しいリポジトリの場合は自動的にフックが使われるし、既存のリポジトリの場合はリポジトリのディレクトリに移動してそこで git init するだけです。Source Tree 使ってる人は</description>
    </item>
    
    <item>
      <title>Chrome Extensionの話をしよう。ようこそ Hometype が創るマウスレスの世界へ。</title>
      <link>http://tkengo.github.io/blog/2014/03/03/introduce-hometype/</link>
      <pubDate>Mon, 03 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2014/03/03/introduce-hometype/</guid>
      <description>vi のようなキー操作で Google Chrome を操作できるエクステンション Hometype の紹介をしたいと思います。元々はエクステンションの作り方の勉強をするために始めた Hometype でしたが github にソースコードを置いて自分が使いやすいようにいろいろ作ってるうちに、会社の同僚が何人か使い始めてたのでとりあえず公開しても良いかなと思って、先日バージョン 0.0.1 を Chrome ストアへ登録しました。ただ実際は、まだ実験的な機能も多く、バグも多く潜んでいると思いますし、テストもないし、最低限の機能しかないので、既存の同類のエクステンションに比べればまだまだ発展途上ではありますが、自分の中でやりたいことはいっぱいあるので開発はずっと続けていく予定です。
Hometype とは 先にも紹介しましたが vi のようなキー操作で Google Chrome を操作できるエクステンションです。バージョン 0.0.1 では以下のキーバインドが定義されています。
 j C-e 下スクロール k C-y 上スクロール C-d 半ページ下スクロール C-u 半ページ上スクロール C-f 1ページ下スクロール C-b 1ページ上スクロール gg 先頭へスクロール G 最後へスクロール H 前に戻る L 次に進む x 現在のタブを閉じる C-p 前のタブへ移動する C-n 次のタブへ移動する I 画面上の最初のテキストエリアにフォーカスする A 画面上の最後のテキストエリアにフォーカスする u 直前に閉じたタブを開き直す U 最近の閉じたタブを検索して開き直す C-h 最近の履歴を検索して戻る b ブックマークを検索して現在のタブで開く B ブックマークを検索して新しいタブで開く f リンクを現在のタブで開くヒントモードへ移行 F リンクを新しいタブで開くヒントモードへ移行 i a インサートモードへ移行 : コマンドモードへ移行 v ビジュアルモードへ移行  ※キーバインドは自分が使いやすい設定になっているので、他の人も使いやすいかというとわかりません。自分でキーバインドを設定できる機能はつけるつもり。</description>
    </item>
    
    <item>
      <title>環境変数を使って capybara のドライバの poltergeist と Selenium を使い分ける</title>
      <link>http://tkengo.github.io/blog/2014/02/17/switch-poltergeist-or-selenium-on-capybara/</link>
      <pubDate>Mon, 17 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2014/02/17/switch-poltergeist-or-selenium-on-capybara/</guid>
      <description>capybara を使ってテストを実行する時は、自分の好きなようにドライバを切り替えることができます。デフォルトでは Rack アプリケーションをテストするための rack-test というドライバが使われていますが spec_helper.rb で
require &#39;capybara/rspec&#39; Capybara.javascript_driver = :selenium  という風に指定すると Selenium 用のドライバを利用して、テスト時は指定したブラウザ(デフォルトでは Firefox)が立ち上がるようになります。
poltergeist について capybara には他に poltergeist というドライバを利用することもできて、これは phantomjs というヘッドレスで動作するブラウザのようなものを利用したドライバです。Selenium の場合はブラウザが立ち上がりましたが poltergeist の場合はメモリ上で動作するため高速です。poltergeist の導入については
 Rails4 + Capybara + PhantomJS (poltergeist) なテスト環境  このあたりを読んでおけば、簡単に導入できると思います。
poltergeist と slenium を使い分ける poltergeist はヘッドレスなので実際にはブラウザは起動せずにメモリ上で実行されていきます。なので画面を見ながらテストを進めることはできません。それ故に高速なのですが、たまにデバッグ用途などで実際に画面を見ながらテストを実行したい時があるので、その場合は
 ドライバを Selenium から poltergeist に一時的に変更 その状態で該当箇所のテストを実行 確認が終わればまた poltergeist に戻す  というようなことをやっていました。が、面倒なので 1 と 3 を飛ばせるように環境変数でドライバを切り替えれるようにしてみた。
自分がよく遣う spec_helper.rp はこうです。
require &#39;capybara/rspec&#39; unless ENV[&#39;POLTERGEIST&#39;] == &#39;off&#39; require &#39;capybara/poltergeist&#39; Capybara.</description>
    </item>
    
    <item>
      <title>git の歴史の辿り方</title>
      <link>http://tkengo.github.io/blog/2014/02/10/how-to-track-git-history/</link>
      <pubDate>Mon, 10 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2014/02/10/how-to-track-git-history/</guid>
      <description>git にはリビジョンを引数として受け取るコマンドがいくつかあります。git show や git reset 、 git log 、 git diff などはその典型でしょうか。これらのコマンドを使う時はリビジョンを指定しますが、その指定の仕方には様々な方法があって、最近自分の知識整理のためにすこし調べてたので、せっかくなのでまとめてみました。
SHA1ハッシュ git はコミット毎にそのコミットに対して SHA1 のハッシュを生成するので、その値をリビジョンの指定に使えます。
$ git show ed9003bcbdb33a0d626911244e5f8e6e244351e9 commit ed9003bcbdb33a0d626911244e5f8e6e244351e9 Author: Kengo Tateishi &amp;lt;xxxx@xxx.com&amp;gt; Date: Sun Feb 9 08:11:25 2014 +0900 開発環境用の設定を追加 ...  コミットのハッシュ値は省略した状態で重複がなければ省略して書くことができます。こういう風に書いても上記と同じ意味になります。
$ git show ed9003b  ブランチ名 / タグ名 git ではブランチやタグは、どこコミットへの参照を持っているかを git が管理しているのでリビジョンの指定に使えます。
$ git show master commit d1e3309be41606db510d80df67b8826edf1b8f16 Author: Kengo Tateishi &amp;lt;xxxx@xxx.com&amp;gt; Date: Sun Feb 9 08:19:31 2014 +0900 テスト設定変更  ローカルのブランチだけではなく、リモートのブランチも指定できます。</description>
    </item>
    
    <item>
      <title>レガシープロジェクトで ruby の capybara を使って仕様化テストをやってみる</title>
      <link>http://tkengo.github.io/blog/2014/01/28/capybara-testing-on-php/</link>
      <pubDate>Tue, 28 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2014/01/28/capybara-testing-on-php/</guid>
      <description>レガシーでテストのないプロジェクトのメンテナンスはつらいものです。テストを書こうにもそもそもテストできるような設計になっておらず、ビューとロジックが分離されていない古い PHP なんかは、なかなかテストを書き始め辛いところもあります。そこで実際にブラウザを起動して自動テストを進めることが出来る capybara を使って仕様化テストをやってみようという試みです。実際に会社では PHP で出来たレガシーなシステムに対して capybara でテストを作ってまわしています。
capybara というと ruby で開発されている有名なウェブアプリケーションテストフレームワークですが ruby でできているからといって ruby のプロジェクトにしか使えないわけではありません。capybara にはテストを実行する際に利用するドライバを指定できて、それには selenium や poltergeist も対応しています。これらのドライバを使ってブラウザを起動して (polgergeist の場合はヘッドレスなので実際にブラウザは起動せずにオンメモリで) 本当にウェブアプリケーションにアクセスしてテストを実行することができます。
この記事では Rails 以外のたとえば PHP や JSP などで出来てるウェブアプリケーションに対して selenium ドライバを使って capybara をやってみたいと思います。
※仕様化テストとは 現在の仕様を元にテストが通るようにテストを書いていきます。これを書いておくことによって、ある箇所のソースコードの変更によって全然別の箇所で影響があって意図しない動作をして不具合になってしまった、なんてことを未然に防ぐことができます。レガシーなプロジェクトのメンテナンスでも心に余裕がもてます。
ruby をインストールする 普段から ruby を使ってる人は既に ruby はインストールされていると思うので、その場合はこのステップは飛ばしましょう。
ruby 以外のプロジェクトで使うにしても capybara 自身が ruby がないと動かないので何はともあれ ruby のインストールから始めます。ruby のインストールは rbenv を使うと楽でね。元々 ruby のバージョン切り替えのためのツールなのですが、別に ruby を複数バージョンいれないとしてもこのツール自体シンプルで使いやすいし、今後 ruby のバージョンが上がってもバージョンアップが簡単なのでとりあえず入れておくといいと思います。
この辺を見れば簡単に ruby のインストールまでできます。
 rbenvリポジトリのREADME(英語) rbenvを使って3分でRubyをインストールする方法まとめ  ruby がインストールできたら、あとで使うので bundler という gem をインストールしておきます。</description>
    </item>
    
    <item>
      <title>spring と direnv を使って Rails と rspec を高速起動。快適開発はじめる</title>
      <link>http://tkengo.github.io/blog/2014/01/24/rails-spring-and-direnv/</link>
      <pubDate>Fri, 24 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2014/01/24/rails-spring-and-direnv/</guid>
      <description>spring は最近流行ってるので、既に知ってる方もいると思いますが Rails のプリローダーです。
Rails を使ってる人だったら bundle exec rails console とか bundle exec rails generate model user とか bundle exec rake routes とか、便利コマンドにお世話になることも多いと思います。
でも Rails ってとても巨大なフレームワークなので、コマンド一つ起動するにも Rails の資産が全部ロードされて結構な時間がかかります。なので Rails をあらかじめバックグラウンドで起動しておくことによって、コマンドの起動時間を大幅に短縮してくれるのが spring です。
前は Gemfile には書かずにシステムに gem コマンドでインストールして spring rake routes とかやってて、コマンドの前に spring と書かないといけないのダルかったのですが、公式のドキュメントを読んでいると最近はまた便利になってるみたいです。
github の README では Rails 4 と Rail 3.2 が対象となっていますが、この記事は Rails 4 前提で書いています。
spring のインストール 最新の spring は Gemfile に書きます。
group :development, :test do gem &#39;spring&#39; end  で</description>
    </item>
    
    <item>
      <title>capistrano をバージョン 3 にアップデートして時代の流れに乗る</title>
      <link>http://tkengo.github.io/blog/2013/12/12/version-up-capistrano-v3/</link>
      <pubDate>Thu, 12 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2013/12/12/version-up-capistrano-v3/</guid>
      <description>2013 年 6 月頃に capistrano のバージョン 3 がリリースされました。かなり久しぶりのメジャーバージョンアップで色々変わっているようです。
Intobox でもデプロイには capistrano を使っていて、今回 capistrano のバージョンアップをしましたので手順の紹介とハマったことなどをまとめたいと思います。
capistrano v3 capistrano v3 は、より良いモジュール化、より簡単なデバッグ、より高速なデプロイ、などを設計目標として掲げています。
変更点が多いのでアップグレードガイドが公式サイトより提供されています。基本的にはここを見ながら進めていくのですが、やることといえば
 Gemfile に gem &#39;capistrano&#39;, &#39;~&amp;gt; 3.0&#39; を追加 bundle install bundle exec cap install  をやって Capfile や config/deploy.rb を変更点に合わせてひたすら修正していくだけになります。ただ、バージョンアップ中にハマったポイントはあったので v2 と v3 の変更点も見ながら紹介していきます。
v2 と v3 の変更点 必要な gem が変わった v3 からは、何をデプロイするかによって必要な gem が異なり、細かく分かれています。たとえば rbenv を使う Rails プロジェクトをデプロイする場合は
gem &#39;capistrano&#39; gem &#39;capistrano-rails&#39; gem &#39;capistrano-bundler&#39; gem &#39;capistrano-rbenv&#39;  と、それぞれ必要な gem を指定してあげる必要があります。一見必要な gem が増えて面倒くさそうですが、これは capistrano が Rails だけのものではなくなったということです(まぁ v2 の頃から Rails 以外でもデプロイできてたわけですが。v3 では明示的に必要なものがモジュール化されています)。</description>
    </item>
    
    <item>
      <title>本当にあったプログラマとデザイナの怖くない話 in Fukuoka.php Vol.11</title>
      <link>http://tkengo.github.io/blog/2013/11/28/collaboration-with-programmer-and-designer/</link>
      <pubDate>Thu, 28 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2013/11/28/collaboration-with-programmer-and-designer/</guid>
      <description>Fukuoka.php Vol.11 に参加してきました。
リンク先にもあるように今回は NO PHP DAY ということで Fukuoka.php という名前を冠しながらも、誰一人として PHP の話をしなかったという珍しい勉強会でした。残念ながらUstreamの中継はなかったためオープンにはなりませんでしたが、いろいろと勉強になってたくさんインプットができたイベントでした。素晴らしい発表の数々は、後々各発表者の方より資料やブログが公開されると思います。Twitter では #fukuokaphp ハッシュタグで流れを追えると思います。
そんな NO PHP DAY な Fukuoka.php で僕も LT 枠をもらっていたので、ひとつアウトプットをしてきました。
プログラマとデザイナのコラボレーション Web 業界では、プログラマとデザイナが一緒に仕事をすることは多いと思います。一般的にプログラマはデザイン業はできません。そしてその逆もしかり、デザイナはプログラミング業はできません。(たまにプログラミングもデザインもどっちも出来て、RailsやるしPhotoshopやるし、なんでも一人でやるぜ、というようなスーパーな人はいますが、そういうのは除外)
そんな中でいかにして効率よくお互いに協力し合いながらサービス開発を進めていけばいいのか、というのはベストプラクティスがありそうでなさそうな、そんな一概には言えない難しい話です。今回は Intobox ではどうやってプログラマとデザイナが協力して開発をしていたのかというプラクティスについて紹介してきました。あくまで Intobox ではこうやった、という事例紹介です。LT では 5 分しか割り当てられてなかったので充分にしゃべれませんでした。補足も込めて、もう一度資料の紹介と内容のまとめを書きたいと思います。
Fukuoka.php でしゃべった資料はこちら。本当に怖くないです。
  本当にあったプログラマとデザイナの怖くない話
Intobox を知らない人はこちらの記事も合わせて。送るをもっとシンプルに。ファイル送信サービス「Intobox」をリリースしました。https://intobox.in
Intobox の開発フロー Intobox ではソースコード管理に git を、リモートリポジトリとして bitbucket を使っています。開発フローは
 bitbucket でイシュー発行 デザイナがモックを作成してイシューに添付 プログラマがモックを元にある程度まで開発する 今度はデザイナがディテールを調整する デザイナがプルリクエストを出す プログラマがプルリクエストを確認してマージ  という流れです。デザイナしかプルリクエストを出していないあたり若干プログラマがリードしてる感じではありますが、プログラマがデザイナに対してプルリクエストを出してもデザイナがわかるところが無いので Intobox ではそれはやってません。逆にデザイナからのプルリクエストをやっているのは、プログラマが作っておいた JavaScript の DOM 操作や Ajax 処理なんかが、タグやクラス名の変更によって壊れていないかどうかを確認するというところで有効に働いていました。
コミュニケーションを欠かさない プログラマとデザイナはお互い畑違いのところでそれぞれ作業をやっています。ともすれば、私達はお互いに何をやっているかをわかっていません。なので、コミュニケーションはとても大事です。進捗確認という意味でも、モチベーションを保つという意味でも、欠かさずに意識しておきたいところです。</description>
    </item>
    
    <item>
      <title>送るをもっとシンプルに。ファイル送信サービス「Intobox」をリリースしました。</title>
      <link>http://tkengo.github.io/blog/2013/11/20/launch-the-intobox/</link>
      <pubDate>Wed, 20 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2013/11/20/launch-the-intobox/</guid>
      <description>「送る」をもっとシンプルに をコンセプトとした Intobox というサービスをリリースしました。
Intobox は Facebook の友逹に対してファイルを送信することができ、送信されたファイルは相手の Dropbox に直接に転送されます。ファイルの受信側では Dropbox のクライアントツールがインストールされていれば Intobox からファイルが送信された後、ダウンロードする手間もなく自動的に自分の端末に同期されます。
Intobox Intobox には Facebook を使ってサインインします。ユーザー登録は必要ありません。サインインできればDropboxの認証画面が出てくるのでそちらも認証を済ませておきます。Dropbox認証時に すべてのファイルやフォルダへのアクセス と表示されますが、実際にはすべてのファイルやフォルダにはアクセスしておらず、受け取り側の Dropbox の Intobox というディレクトリ以下への保存以外の操作は行いません。
Dropbox の認証が完了すると自分の Facebook の友逹一覧が表示されます。ファイルを送信するためには相手側も Intobox で Facebook と Dropbox の認証を完了させておく必要があります。まだ認証が完了していない相手は「招待する」という状態になっているので、ファイルを送るために Intobox のユーザーになってもらいましょう。 相手側の Facebook と Dropbox の認証が完了すれば、今度は「ファイルを送る」という状態になります。
これで準備は完了です。あとは友逹をクリックするとファイル送信用のダイアログが表示されますので、送信したいファイルを選んで送信するだけです。少し待てば自動的に相手の Dropbox にファイルが届いています。
セバスチャン Intobox のトップにどんと存在感のあるキャラクター セバスチャン がいます。彼は Intobox のマスコットキャラクターです。
Intobox では公式に Facebook のページと Twitter のアカウントを持っていて、セバスチャンが運営を頑張っています。
Facebook ページはこちら
Twitter アカウントはこちら
Intobox についての情報を書き込んでいきますので、よかったらフォローしてみてください。
良いチームに巡りあう・作り上げる Intobox は会社の仲の良い人達とのチームで開発をしました。チームと言っても今は2人だけなのですが(元々は3人いたけど1人はプライベートとの兼ね合いで途中から開発にほぼコミットできなくなった)。さて、会社の人と一緒に作ったと言っても、会社の業務とは全然関係ないところでプライベートな時間を使ってやってきました。構成としてはプログラマ1人、デザイナ1人で、それぞれプログラミングとデザイン業を分担してやって、ディレクションは空いた時間で2人で協力して進めていました。
しかし、業務外でやっていると明確な期限(納期)というものがありません。納得の行くまで作りこんで作りこんで、ようやく完成させたものをリリースさせることもできます。忙しくて手を付けれなくなれば、そこで開発を停止することもできます。要するになんでも自由にしてしまえます。自分たちで。
個人のプライベートな時間を使っているとその辺が緩くなってしまい、頑張ったはいいけど結局は何も得ることがなかったり、出来上がったものの完成度が低く認知してもらえなかったりすると、とてももったいないです。別に個人の時間なので問題はないと思うのですが、せっかくやるならそういうのは避けたい。</description>
    </item>
    
    <item>
      <title>FacebookChatAPIを使ってFacebookの友逹にメッセージを送信する</title>
      <link>http://tkengo.github.io/blog/2013/10/23/send-chat-message-to-facebook/</link>
      <pubDate>Wed, 23 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2013/10/23/send-chat-message-to-facebook/</guid>
      <description>Facebook にはチャット機能があって、送ったチャットはここで見ることが出来ます。
もし相手がオンラインなら、画面右下にこんな感じのチャットダイアログが表示されます。
このチャット、使っている人も多いかと思いますが Facebook は Chat API というチャットメッセージ送信のための API を提供していて、この API を通して Facebook の友逹にチャットを送信できます。この Chat API は Graph API とはまったく別の物で、使い方も違います。Graph API を ruby から扱うための gem は他にもたくさんあるのですが、それらから Chat API を扱うことはできません。
今回、自分で作ってる Web サービスに通知の仕組みを組み込みたくて Chat API を ruby から利用するための gem を作って公開したので、それを紹介したいと思います。
Chat API の仕様については Facebook Developers のページで確認できます。
https://developers.facebook.com/docs/chat/
FacebookChat facebook_chat というそのまんまの名前の gem を作りました。ソースは github で公開しています。
https://github.com/tkengo/facebook_chat
使い方はリポジトリの README にだいたい書いているのですが、ここでも紹介します。
インストール bundler を使っている場合は Gemfile に以下の行を追加して
gem &#39;facebook_chat&#39;  そして
$ bundle install  してください。</description>
    </item>
    
    <item>
      <title>私達はトトロでさえキャンバスに描画できる</title>
      <link>http://tkengo.github.io/blog/2013/09/22/now-we-are-able-to-draw-totoro-to-canvas/</link>
      <pubDate>Sun, 22 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2013/09/22/now-we-are-able-to-draw-totoro-to-canvas/</guid>
      <description>先日 @monochromegane と一緒に昼ごはんに行ってペペロンチーノを食べてた時「家でもペペロンチーノを作る」という話をしていたら『Vim でペペロンチーノ作るプラグインまだ？』みたいな誰得プラグインの話をしていた僕です。こんにちは。
そんな誰得プラグインに負けないくらい誰得なものが出来上がってしまったのですが、せっかくなので公開しておきます。
HTML5 に canvas というブラウザ上に図を書くための機能があります。結構いろいろなことが出来て、パーティクルを飛び交わせたり、かっこいいアニメーションを作ったり、Flash ばりの表現力があります。前々からこの canvas の勉強をしてみたいと思っていたので、一つなにか作ってみようと思って出来たのがこれです。
canvas にレインボートトロを描画する ※Google Chromeでの閲覧推奨です。1分程度のアニメーションですが、アニメーション中は結構CPUを使います。
ソースはブラウザから ソースの表示 とかでも見れますし、もしくは github にも公開しています。
HTML5 の canvas を使う canvas の使い方に関しては HTML5.jp の Canvas リファレンス が詳しいですが、一応ソースの解説のために簡単な説明だけ書いていきます。
canvas を使うためには、まず以下のような HTML を作ります。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;canvas id=&amp;quot;stage&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  これだけです。HTML に canvas タグさえあれば、あとはこれを JavaScript で操作するだけです。JavaScript では
canvas = document.getElementById(&#39;stage&#39;); context = canvas.getContext(&#39;2d&#39;);  という風にキャンバスのコンテキストを取得して、それを使って描画していきます。getContext の引数に 2d と渡す辺り、3Dの表現も扱えそうですが、まだまだそこまで到達できてません。
サンプルのトトロは、半径 3px の円を繋げてトトロの形を作っています。円を書くためにはコンテキストの arc というメソッドを使って
context.beginPath(); context.</description>
    </item>
    
    <item>
      <title>Ruby on Rails を使って Dropbox にファイルを送信する</title>
      <link>http://tkengo.github.io/blog/2013/09/14/dropbox-api-on-ruby-on-rails/</link>
      <pubDate>Sat, 14 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2013/09/14/dropbox-api-on-ruby-on-rails/</guid>
      <description>Ruby on Rails を使って Dropbox の API を呼び出してファイルを送信したかったので少し調べてみました。DropboxAPI は事前に OAuth 認証でアクセストークンを取得しておき、そのトークンを使って API にアクセスするという一般的なやり方です。
Dropbox アプリの作成 まずは Dropbox のアプリを作らないといけません。アプリに対してユーザーが認証を行ってアクセストークンを発行してもらいます。Dropbox のアプリは https://www.dropbox.com/developers/apps ここから作ることが出来ます。この記事では Dropbox アプリは作成済みの前提で進めていきます。
ちなみに Dropbox アプリは作り方によって、フルアクセスだったり特定の権限しかもらえなかったりします。アプリを作る時に、ウィザード形式でいくつか質問がありますのでそれに答えていく形になります。
アクセストークンの取得 Dropbox の OAuth 認証は OAuth 1.0 と OAuth 2.0 の2つのバージョンがあります。Dropbox としては OAuth 1.0 でも OAuth 2.0 でもどちらでもアクセストークンを取得できる API は用意されているのですが、後述する DropboxSDK がどうも OAuth 2.0にしか対応していない ようなので OAuth 2.0 の方を使います。
omniauth の Dropbox 用ストラテジを準備する ruby で OAuth 認証するといえば有名なのは omniauth ですね。omniauth の Dropbox 用ストラテジは OAuth 1.0 のものしかありませんでしたので OAuth 2.</description>
    </item>
    
    <item>
      <title>database_cleaner v1.1.0 以上を SQLite で使うと落ちる</title>
      <link>http://tkengo.github.io/blog/2013/09/06/database-cleaner-bugfix/</link>
      <pubDate>Fri, 06 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2013/09/06/database-cleaner-bugfix/</guid>
      <description>とある Rails の開発で database_cleaner という gem を使っていました。テストを走らせた後に DB を綺麗サッパリにしてくる便利 gem です。これの最新版を SQLite で使っていたのですが、どうもこんなエラーが出て落ちてしまいます。
`db_version&#39;: undefined local variable or method `postgresql_version&#39; for #&amp;lt;ActiveRecord::ConnectionAdapters::SQLite3Adapter:0x007fa2cea3af48&amp;gt; (NameError)  おっと DB は SQLite を使ってるのに、なぜか postgresql_version というメソッドを呼びだそうとしてるようです。はて、なんでだ&amp;hellip;
結論から言うと database_cleaner のバージョン 1.1.0 からあるバグのようです。ずっとソースを追いかけていって、バグの箇所は特定できたので修正しようと思ったら既に pull-request が出ていました。
たぶんそのうち取り込まれると思うので、そうすれば SQLite でも使うことが出来るようになると思います。
取り急ぎ SQLite で最新版の databse_cleaner を使いたければ、コメントにもあるように Gemfile に
gem &#39;database_cleaner&#39;, &amp;quot;~&amp;gt; 1.1.1&amp;quot;, :git =&amp;gt; &#39;https://github.com/tommeier/database_cleaner&#39;, ref: &#39;b0c666e&#39;  とすればいけるようですね。</description>
    </item>
    
    <item>
      <title>郵便番号から住所を補完する jquery.ajaxzip2 を拡張したよ</title>
      <link>http://tkengo.github.io/blog/2013/06/29/jquery-ajaxzip2-extend/</link>
      <pubDate>Sat, 29 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2013/06/29/jquery-ajaxzip2-extend/</guid>
      <description>先日、郵便番号から住所を補完する jQuery のプラグイン jquery.ajaxzip2 を紹介しました。
これは AjaxZip 2.0 - Ajax郵便番号→住所自動入力フォーム（CGI不要版）を jQuery プラグインとして実装したもので、利用するためには自前で JSON 形式の住所データをサーバーに配置する必要がありました。そこで JSON 形式の住所データを準備しなくても良いように JSONP 形式の住所データも読み込めるように jquery.ajaxzip2 を少し拡張してみました。
外部の API を利用して住所を補完する JSONP については、詳しくは検索すれば情報が沢山でてきますのでここでは割愛しますが、要するに JSONP を使えば外部のサービスが提供する郵便番号検索 API などから住所を補完できるようになります。
郵便番号から住所データを引ける JSONP 形式対応の API を提供しているサービスはいくつかあります。例えば
 グルーブテクノロジー株式会社の郵便番号検索API ricollab 郵便番号検索 郵便番号-住所検索API  などです。jquery.ajaxzip2 では住所データをこれらの API から取得して住所を補完することができます。使い方は github の方に詳細を記載していますが、ここでも紹介したいと思います。
今回は グルーブテクノロジー株式会社の郵便番号検索API を利用してみます。
※利用する際は各サービスの利用規約などを良く読んで自己責任でお願いします。
パスを指定する API のパスを設定します。郵便番号の部分は %ZIP3% のプレースホルダを利用して、コールバック関数の名前も指定しておきます。データ種別も jsonp を選択しておきます。
$.fn.zip2addr.defaultOptions.path = &#39;http://api.postalcode.jp/v1/zipsearch?zipcode=%ZIP3%&amp;amp;callback=zip2addr&#39;; $.fn.zip2addr.defaultOptions.type = &#39;jsonp&#39;;  住所データの形式を理解する API がどのような形式でデータを返してくるのかを確認します。このデータを元に 郵便番号をキー として 都道府県、市区町村、町域、番地の配列を値 とした、ハッシュを作ってそれを返すようにします。</description>
    </item>
    
    <item>
      <title>郵便番号から住所を補完するjQueryプラグインを作ってみた</title>
      <link>http://tkengo.github.io/blog/2013/06/23/jquery-ajaxzip2/</link>
      <pubDate>Sun, 23 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2013/06/23/jquery-ajaxzip2/</guid>
      <description>郵便番号から住所を自動的に補完してくれる JavaScript のライブラリに AjaxZip 2.0 - Ajax郵便番号→住所自動入力フォーム(CGI不要版) がありますが、それを jQuery のプラグインとして実装したものを作ってみました。
jquery.ajaxzip2
通常版と、スペースや改行などが圧縮された minify 版があります。使い方はリンク先の github に書いてあるので参考にしてください。
また jquery.ajaxzip2 を実装するにあたって、さらに使いやすくするために従来の AjaxZip2 を少し拡張しました。
拡張機能 次のような機能を新たに追加しています。
住所補完後の動作をコールバック関数で指定可能 郵便番号から住所を補完する際に JSON 形式の住所データを非同期に取得しにいきますが、それが完了した後に呼び出されるコールバック関数を指定できるようにしました。
たとえば以下のようにして、郵便番号に対する住所が見つかって補完が完了した場合に、メールアドレスにフォーカスを当てることができます。
$(&#39;#zip&#39;).zip2addr({ success: function() { $(&#39;#mail&#39;).focus(); } });  コールバック関数の引数には、見つかった住所データが渡されます。
住所が見つからなかった時の動作をコールバック関数で指定可能 郵便番号から住所が見つからなかった場合に呼び出されるコールバック関数を指定できるようにしました。
たとえば以下のようにして、住所が見つからなかった時にエラーメッセージを表示することができます。
$(&#39;#zip&#39;).zip2addr({ error: function() { $(&#39;#error&#39;).text(&#39;住所が見つかりませんでした&#39;); } });  フォーム要素以外への住所補完 div 要素や a 要素などでも ID が指定してあればそこへ補完できるようにしました。
たとえば以下の様な HTML の場合でも
郵便番号 &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;zip&amp;quot; id=&amp;quot;zip&amp;quot; /&amp;gt; 都道府県 &amp;lt;div id=&amp;quot;pref&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; 市区町村 &amp;lt;div id=&amp;quot;city&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; 町域 &amp;lt;div id=&amp;quot;area&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; 番地 &amp;lt;div id=&amp;quot;street&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;  通常通りこのプラグインを呼び出すと</description>
    </item>
    
    <item>
      <title>gitのコミットの歴史を改変する(git rebase) 2 / 2</title>
      <link>http://tkengo.github.io/blog/2013/06/08/git-rebase-reference2/</link>
      <pubDate>Sat, 08 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2013/06/08/git-rebase-reference2/</guid>
      <description>git rebase パート1の続きです。
fixed(コメントは変更せずにコミットをまとめる) fixed は squash と同じく1つ前のコミットとまとめる機能がありますが squash と違うのはコメントはそのままにするということです。
squash と同じ説明になりますが 70b3379 の メソッド名のタイポ修正 を何事もなかったかのようにしたい時は cce19c9 とまとめてしまいます。いつものように
[kengo@tkengo-mac] $ git rebase -i cce19c9~1  こうして
pick cce19c9 通信用のクラスの実装とテストの追加 fixed 70b3379 メソッド名のタイポ修正 pick aebf22c テストが落ちてたので修正  とします。すると squash の場合はこの後にコメントを入力する画面が出て来ましたが fixed の場合はそれが出ません。まとめる先のコミットのコメントがそのまま使われますので rebase の作業はこれで終了です。 squash の時と同じように、タイポの歴史はなかったことになりました。
exec exec はコミットに指定するものではありません。
[kengo@tkengo-mac] $ git rebase -i cce19c9~1  とすると
pick cce19c9 通信用のクラスの実装とテストの追加 pick 70b3379 メソッド名のタイポ修正 pick aebf22c テストが落ちてたので修正  と出ますが、例えば
pick cce19c9 通信用のクラスの実装とテストの追加 exec make test pick 70b3379 メソッド名のタイポ修正 exec make test pick aebf22c テストが落ちてたので修正 exec make test  という風にコミットとは別の行に exec を入れこんで、その後にコマンド名を記述します。この例では各コミットの後に make test というコマンドを実行してくれます。</description>
    </item>
    
    <item>
      <title>ZendFramework で HTTP 通信部分をスタブ化してテストする</title>
      <link>http://tkengo.github.io/blog/2013/06/02/zend-framework-http-stub/</link>
      <pubDate>Sun, 02 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2013/06/02/zend-framework-http-stub/</guid>
      <description>テストしてますか？
こないだ業務で ZendFramework を使ったアプリケーションで HTTP 通信の部分をスタブアウトしてテストしたかったので、実際にやってみました。そんなに難しくなかったので、是非やってみると幸せになれるかも！
前提  ZendFramework バージョン1系 Zend_Http_Client を使って HTTP 通信をしている  ZendFramework のバージョン2がリリースされてからもうしばらく経ちますが、業務ではバージョン1を使ってる所は結構あるんじゃないでしょうか。
それから ZendFramework を使って HTTP 通信をしようとする場合 Zend_Http_Client というクラスがあります。名前からもわかりますが HTTP 通信のためのクライアントで、通信部分の面倒を見てくれるクラスです。今回のアプリケーションは HTTP 通信部分に Zend_Http_Client を使っていたので、それ前提で話を進めます。
目標 最初にスタブアウトとか言いましたが、テストの世界ではスタブとかモックとかいった単語が良く出てきますよね。今回はスタブなのですが、言葉の定義や、それがどういうものなのかは、詳しいサイトがいっぱいあると思うのでそっちに任せるとして、今回やりたかったことは
 外部サービスのAPIと通信するクラスがある そのクラスのテストを書く ただしネットワークに繋がっていなかったり、外部サービスが落ちてる時もテストが成功するようにしたい  ということです。HTTP 通信の部分をスタブにして実際の通信を走らせないようにします。
外部サービスAPIクラス たとえば Zend_Http_Client を使って HTTP 通信をする以下の様なコードがあったとします。
&amp;lt;?php class ServiceApiClient { public function methodA() { ... $response = $this-&amp;gt;request($paramsA); return $response[&#39;result&#39;] == &#39;OK&#39;; } public function methodB() { ... $response = $this-&amp;gt;request($paramsB); if (isset($response[&#39;id&#39;])) { return $response[&#39;id&#39;]; } else { return 0; } } public function request($params) { $client = new Zend_Http_Client(&#39;http://.</description>
    </item>
    
    <item>
      <title>Fukuoka.php Vol.7 1周年に参加してきた</title>
      <link>http://tkengo.github.io/blog/2013/05/30/fukuoka-php-anniversary/</link>
      <pubDate>Thu, 30 May 2013 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2013/05/30/fukuoka-php-anniversary/</guid>
      <description>2013/05/29(水)にFukuoka.php Vol.7 1周年が開催されたので、参加してきました。
僕もちょこちょこ参加させてもらっては、たまに発表枠をもらってしゃべったりしてたのですが、早いものでもう1年経つのですね。この1年で自分自身も大きく成長しました。後から読み返してみたら、どうも二番煎じみたいな日記になってしまいましたが、まあいっか。
勉強会に参加する目的 勉強会に参加する時、どういう気持ちで参加しているでしょうか。
 純粋に技術の勉強をする 新技術に触れてモチベーションを高める  それぞれ理由はあると思います。僕も最初は純粋に技術目的で参加していました。
もっと大事なこと もちろん技術の勉強も大事なのですが、せっかくいろんな人が集まる場なのですから、それだけじゃなくてもっと出来ることがあるはず。
それは
コミュニケーション 是非とも他の参加者の方達と仲良くなりたいと思っています。そこら中で言われててもうあたりまえのようなことですが、この業界では人脈はとても大事なものですよね。僕はたくさんの人といろんな視点から話せるのはとても刺激があると思います(もちろん技術についても、また日常の他愛ない話題についても)
昔は勉強会に参加して、最初の「こんにちはー」と、最後の「おつかれさまでしたー」ぐらいしか会話をしていませんでしたが、やっぱそれはもったいないなぁです。
もっと言うと、インターネット上に情報が潤沢にある今時、技術の勉強それ自体は頑張れば1人でもいくらでも出来ます。だけど、知り合いを増やすっていうことこそ、みんなが集まる勉強会みたいな場じゃないと出来ないんじゃないかなーと思います。
そして自主的に積極的に LTなんかをやります！これもよく言われることなのですが、参加者と発表者の違いはとても大きいです。考えてみると、発表者にはただの参加者よりもメリットがあるんです。
 説明するためのスライド作るので自分の中の知識が体系的に整理できる こっちから話かけなくても向こうから話かけてきてくれる！「今日しゃべってたあのネタなんですけどね、いいですね。うちでも&amp;hellip;」みたいな。 みんなに自分のことを知ってもらえる なんか達成感  それから、メリットとはまた違うかもしれませんが、自分のしゃべりが終わった後に質問とかたくさんでるのも嬉しいですね。みんな興味をもってくれたのかな、って思うと技術の紹介をした甲斐もあります。
アウトプットにフィードバックがあると嬉しいのは技術者ならみんな知っているはず！
今回の発表 今回のFukuoka.phpでは発表枠をいただいていましたので、VagrantとChef-soloを使った開発環境の構築の仕方について少ししゃべってきました。 実際に職場での開発に活用してます。大活躍です。
資料はこちら https://speakerdeck.com/tkengo/vagrant-plus-chef-solo
なんとなく勉強会に参加している人。ちょっと気の持ちようを変えて参加してみませんか。</description>
    </item>
    
    <item>
      <title>gitのコミットの歴史を改変する(git rebase) 1 / 2</title>
      <link>http://tkengo.github.io/blog/2013/05/16/git-rebase-reference/</link>
      <pubDate>Thu, 16 May 2013 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2013/05/16/git-rebase-reference/</guid>
      <description>git には rebase というとても便利なコマンドがあります。その中でも特に便利なのが -i または --interactive オプションです。便利なのですがよく忘れるのでまとめもかねてこの記事で詳しく紹介します。
前提 この記事では説明のために以下のようなコミット状態である前提で話を始めます。よくあるコミットの流れです。
git rebase -i -i は --interactive とあるように、対話的に rebase が実行できるコマンドです。これでなにが出来るかというと
 コミットメッセージを編集する コミットをまとめる コミットを分割する コミットの順番を移動させる コミットを削除する  など、いろんなことが出来ます。基本的な構文は
[kengo@tkengo-mac] $ git rebase -i &amp;lt;commit&amp;gt;  これだけ。 &amp;lt;commit&amp;gt; には特定のコミットを指定します。たとえば
[kengo@tkengo-mac] $ git rebase -i HEAD~3  とすると、最後から3つまでのコミットについて、上に書いた何かしらの操作(コミットメッセージ編集だったり順番を入れ替えたり)を出来ます。このコマンドを実行するとテキストエディタが開いてコミットの一覧が表示されて
pick cce19c9 通信用のクラスの実装とテストの追加 pick 70b3379 メソッド名のタイポ修正 pick aebf22c テストが落ちてたので修正 # Rebase cce19c9..aebf22c onto b8e5722 # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like &amp;quot;squash&amp;quot;, but discard this commit&#39;s log message # x, exec = run command (the rest of the line) using shell # # These lines can be re-ordered; they are executed from top to bottom.</description>
    </item>
    
    <item>
      <title>zshのターミナルにリポジトリの情報を表示してみる</title>
      <link>http://tkengo.github.io/blog/2013/05/12/zsh-vcs-info/</link>
      <pubDate>Sun, 12 May 2013 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2013/05/12/zsh-vcs-info/</guid>
      <description>zshのターミナルに今いるパスのリポジトリの情報を表示してみることにします。最終目標はこんな感じ。
 ブランチ名を表示 全てコミットされてきれいな状態であれば緑色 addされていないファイルがあれば+マークをつけて赤色 commitされていないファイルがあれば!マークをつけて黄色  ちなみにこの記事に書いてあることは zsh のバージョンが 4.3.10 以上に限って有効です。
さて、これを実現するには vcs_info というものを使います。以下のような記述を ~/.zshrc に追加します。
# この行は現在のパスを表示する設定です。ブランチを表示して色をつける設定とは関係ありません RPROMPT=&amp;quot;%{${fg[blue]}%}[%~]%{${reset_color}%}&amp;quot; autoload -Uz vcs_info setopt prompt_subst zstyle &#39;:vcs_info:git:*&#39; check-for-changes true zstyle &#39;:vcs_info:git:*&#39; stagedstr &amp;quot;%F{yellow}!&amp;quot; zstyle &#39;:vcs_info:git:*&#39; unstagedstr &amp;quot;%F{red}+&amp;quot; zstyle &#39;:vcs_info:*&#39; formats &amp;quot;%F{green}%c%u[%b]%f&amp;quot; zstyle &#39;:vcs_info:*&#39; actionformats &#39;[%b|%a]&#39; precmd () { vcs_info } RPROMPT=$RPROMPT&#39;${vcs_info_msg_0_}&#39;  最初はネットから拾ってきてそれをそのまま使ってて動くには動いてたのですが、正直設定内容を全然理解してなくってイミフでしたので、勉強もかねてマニュアルを読んでちょっと改造してみました。以下つらつらと解説していきますが、ほぼマニュアルの日本語訳みたいなものですが自分用まとめということで。
vcs_info って？ vcs は Version Control Systems のこと(だと思う)。
subversion とか CVS とか git とかいわゆるバージョン管理システムと呼ばれるものから情報を自動的に取得してくれる関数です。
vsc_info 関数で取得した情報をもとに、それをプロンプトに表示したりします。</description>
    </item>
    
    <item>
      <title>Vagrant &#43; librarian-chef で作るローカル開発環境</title>
      <link>http://tkengo.github.io/blog/2013/04/09/vagrant-and-librarian-chef/</link>
      <pubDate>Tue, 09 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2013/04/09/vagrant-and-librarian-chef/</guid>
      <description>Vagrant は VirtualBox を使って VM を簡単に構築できるプロダクトです。既に多くの情報が出回ってるのでここでは詳しく説明しませんが、開発者にとっては非常に役立つツールとなっていますね。今回はただ Vagrant を使って VM を構築するだけではなく librarian-chef という gem を使って、より簡単に環境構築することを目指します。
librarian-chef librarian-chef は Chef 版の Bundler のようなツールです。 Cheffile というファイルに (Bundler の Gemfile みたいだ) 必要なクックブックの名前やリポジトリを指定していきます。
インストール まずはインストールします。 gem なのでインストールはコマンド一発。
$ gem install librarian-chef  これで librarian-chef というコマンドが使えるようになっているはずです。 rbenv などを使っている場合は
$ rbenv rehash  も忘れずに。
Cheffile の作成 インストールが終わったら
$ librarian-chef init  とコマンドを実行します。するとカレントディレクトリに Cheffile というファイルが以下のような内容で出来ているはずです。
#!/usr/bin/env ruby #^syntax detection site &#39;http://community.opscode.com/api/v1&#39; # cookbook &#39;chef-client&#39; # cookbook &#39;apache2&#39;, &#39;&amp;gt;= 1.</description>
    </item>
    
    <item>
      <title>ペパボに入って学んだたった1つの事</title>
      <link>http://tkengo.github.io/blog/2013/03/08/what-i-have-learned-about-in-pepabo/</link>
      <pubDate>Fri, 08 Mar 2013 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2013/03/08/what-i-have-learned-about-in-pepabo/</guid>
      <description>2012年2月。僕は前職を辞めて、株式会社paperboy&amp;amp;co.(愛称:ペパボ)へ転職しました。転職してちょうど1年になるので、ここらでチラ裏的に自分用まとめでも書いてみる。
paperboy&amp;amp;co. ペパボはロリポップ！やムームードメインなど、いろいろなサービスを提供しています。 もっとおもしろくできる を理念として インターネットで可能性をつなげる、ひろげる というミッションをかかげて頑張っています。 2012年2月。僕は、この会社のムームードメインというサービスの中の人になって、開発・運用をするようになりました。
アウトプット精神 ペパボには、自分のやってきたことやハマったことを、しっかりまとめて外に発信してる人がいっぱいいます。RubyやPerl界隈で有名な人や、ブログが有名な人、それから勉強会やカンファレンスなどのイベントでのスピーカーをつとめる人も大勢います。
こんな僕でもPHP Matsuri 2012というイベントでスピーカーをすることができました。それは、ペパボの大切にしてほしいことの1つにあるように、会社の文化としても根付いているし、そしてアウトプットすると外の世界と繋がることができる、ということを知ったからでした。
オープンソースへの貢献も活発で、githubを使ってみんな積極的にプルリクエストを送っています。これによって僕も大きく考えが変わりました。そう、バグを見つけたら、直るのを待つんじゃなくて 自分から直すんです 。
仕事に対する姿勢 幸か不幸か、今の僕の周りにはモチベーションの高い人がたくさんいます。そういう人達はもれなく技術力も高いときています。その輪の中に自分も入って、そして周りの人と刺激しあい、自分も一緒に成長できる環境があるのは技術者にとって、とても幸せな事です。
裏を返せば、うかうかしていると周りに埋もれてしまって、自分が輝きを失ってしまうってことでもあります。ただ、それがいい意味での緊張感となり心地よく、僕の士気を高めてくれて、そしてそれが自分の成長にもつながっています。
業務改善の余地あり 僕が担当しているムームードメインは9年という長い歴史があります。長い歴史の中で積み重ねられてきたコード量はそれはもう半端無く多く、そしてカオス的にレガシーです。PHP Matsuriでも少し紹介しましたが、僕が入社した当時は、テストもねぇ、個人開発環境もねぇ、自動デプロイもねぇ、バージョン管理システムも使いきれてねぇ、てな感じで結構大変でした。
こういう開発の本業以外のところってなかなか面倒くさくて取り組まないんですよね。でもムームードメインのチームメンバーは違うんです。みんなで一緒になって問題に取り組んで、ばっさばっさと解決していき、今は全部解決しちゃっています。新しいことにも怖気づかずに全力で取り組んでいます。
ムームードメインのチームの人と一緒にこんなことをやってきました。(僕の少し後にペパボに入社して今も一緒にムームードメインでやってる人です)
改善の余地あり。これは何も悪いことばかりではなく、良い意味で、僕らの成長の糧にもなっています。
仕事外での活動 ペパボでは毎年 お産合宿 というイベントを開催しています(2012年のお産合宿)。業務とは全く切り離されたもので、週末の2日間で何か作ってみるというものです(もちろん事前準備である程度開発しててもいいですが、業務時間中にやってはいけません)。Webサービスであったり、動画であったり、アプリであったり、様々ですが、仕事とはまったく別の部分でみんなで協力して何か一つ創ります。
2012年は僕も参加して wellsaid というサービスを作り上げました。
会社の同僚と友逹のようにコミュニケーションを取りながら、みんなでやりたいように創りたいものを創り上げていく。すごい楽しい。こういうのすごく大事だと思います。
そして最近、しばらく一人で暖めてたwebサービスのアイデアを具体的にメモ帳に書きだして、会社のプログラマとデザイナを一人ずつ誘って(巻き込んで)サービスをリリースする計画を進めています。一人でやるのと、みんなでやるのは全然ワクワクが違います。こうやって自分のアイデアに賛同して、一緒に作ってくれる人がいるのは幸せなことです。
たった1つのことって書いてたけど？ 一度こういうタイトルでブログ書いてみたかっｔ。じゃなくてぐたぐた書いてきたけど、これらを通して結局は僕が思うことは
仕事が楽しいと成長も早い なんや当たり前のことかもしれないんですけど、ペパボに入って強く思うようになりました。自分で言うのもなんですが、この1年で自分の技術力は飛躍的に成長したと思います。それは周りの人に支えられて、考え方も変わってきて、何よりイヤイヤ仕事してなかったのが大きいと思います。それほど前職とは仕事に対する向き合い方が変わりました。
業務を与えられたと思って仕方なくやっていると、身に入りません。上に書いた業務改善なんかも自分から こうしたい！ と話を出して、先が見えないながらも頑張って改善してきました。お産合宿や独自サービスなんかも自分らで発案して自発的に業務外でやることで、最新の技術を使えたり、それを覚えたり、そしてさらには業務にフィードバックできたりなんかします。
まだまだ未熟なところは沢山ある、人生一生勉強です。仲間と一緒に高みを目指そう。</description>
    </item>
    
    <item>
      <title>webistranoを使ってたとえばZendFrameworkをデプロイしてみる</title>
      <link>http://tkengo.github.io/blog/2012/11/30/cap-and-webi/</link>
      <pubDate>Fri, 30 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2012/11/30/cap-and-webi/</guid>
      <description>Ruby on Rails のデプロイ自動化でよく使われる capistrano と、そのGUI環境の webistrano ですが、もちろん Ruby on Rails 以外にも使うことができます。 今回は ZendFramework のデプロイをしてみようと思います。
ゴール ここでは、以下のような状況のもと本番環境にデプロイする準備をします。
 github 上の master ブランチにあるソースコードをデプロイする。 リポジトリでは ZendFramework 本体やログディレクトリなどは管理していない。  インストール capistrano は ruby 製です。まずは ruby がないと始まらないので最初に ruby をインストールします。1.8.6 以上が必要です。それから webistrano は DB として mysql を利用しますので、こちらもインストールしておきます。ruby と mysql のインストールは他に詳しい記事がいっぱいあるので割愛。
ruby と mysql が準備できたら capistrano と webistrano をインストールします。といっても webistrano をインストールするときに一緒に capistrano も入るので webistrano をインストールするだけです。
$ cd path/to/webistrano // git から clone $ git clone git@github.</description>
    </item>
    
    <item>
      <title>PHP Matsuriの本番は夜遅くから</title>
      <link>http://tkengo.github.io/blog/2012/11/11/php_matsuri/</link>
      <pubDate>Sun, 11 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2012/11/11/php_matsuri/</guid>
      <description>11月の3日、4日に福岡の福岡Ruby・コンテンツ産業振興センターで PHP Matsuri 2012が開催されました。
初参加のPHP Matsuri 今回は僕もこれに参加してきました。初参加です。
ただし、一般参加者枠ではなくて、スポンサー枠でしかもスピーカーとして！
もともとPHP Matsuriは初回から参加したいな〜とは思っていたけど、開催地が東京や大阪でとても行ける場所じゃ なかったので参加したことがありませんでした。今回は開催地が 福岡 だったので、これはもう参加するしかない！ と思ってたところ、ペパボがスポンサーになってスポンサー枠で参加することになりました。
スポンサーには発表枠がついてて、もちろん僕がそこで発表することに。 ペパボの福岡支社ではちょうど環境改善の取り組みをやっていたので、迷いなくそれについて紹介することにしました。
PHP Matsuriの本番は夜遅くから ところでPHP Matsuri 2012のタイムテーブル を見てみると23時頃が 闇？？ となっています。
これはなんだろう？？と思っていましたが、、、アン・リーダブルコード選手権というイベントでした。 俺の知ってるこのクソコードこそ、一番読みにくいんだ！ というクソコードを紹介して 一番のクソコードを紹介した人には景品が当たるという。
ゲストセッションやスポンサーセッションも終わり、夜も更けてきた23時頃に謎の盛り上がりと共に始まりました。 これまでで一番もりあがっとるｗｗ
缶ビールとかで乾杯をするの図 なんかもうこの闇PHP Matsuriがメインで今までのは全部前置きみたいな感じがしてきた。 とても楽しいイベントでした。
ペパボのスポンサーセッション 僕はスポンサー枠で参加して、当日は恐れ多くも発表者としてペパボ内でやってる環境改善の取り組みについて お話をさせてもらいました。環境改善の取り組みはまだまだやることはいっぱいなのですが、 以前に比べると比べ物にならないほどよくなってきています。PHP Matsuriでも紹介しましたが、 当日しゃべり切れなかった部分や、復習もかねてここでもう一度紹介したいと思います。
発表に使った資料はここにあります。
開発環境の改善 福岡支社ではロリポップ！やムームードメインの開発・運用を行なっています。 これらの開発サーバーはもともと1台でした。この共用サーバーにApacheやPHPなど必要なものをインストールし、 そしてSambaを入れて 共通のディレクトリに開発者全員が接続してファイルを編集 していました。これだと
 他の開発者と同じファイルを編集しようとしたらファイルがロックされてる 自分の開発してる部分とは全然関係ないところでバグっている 気軽にvar_dumpでデバッグできない  という問題がありました。
現在はmondrescueというツールを使って本番環境をVMイメージ化して、 それを各個人がクローンしてそこで開発をするように移行を進めています。 これで上記の問題はすっぱりすべて解決してくれます。
VMのクローンにはMaglicaというオープンソースを社内で使っています(ペパボのmizzyさん作)。
バージョン管理ツールの乗り換え ロリポップ！とムームードメインはバージョン管理をsvnからgitへ移行しました。 そして中央リポジトリとしてgithubを使っています。 今ではペパボのほぼ全サービスがgithubへの移行が完了しており、誰でもどのサービスのコードでも見ることができます。
githubには pull-request という機能があり、これのお陰でとてもコードレビューがしやすくなりました。
それにペパボは福岡と東京にオフィスをかまえているのですが、福岡東京間のエンジニアの交流も githubのおかげでできています。東京のエンジニアが福岡で開発しているムームードメインの ソースコードにツッコミをいれる、なんて光景もよく見られます。
ちょっと苦労した話 ムームードメインではgithubへの移行にあたってソースコード中のパスワードを外部ファイルへ分離し、 その外部ファイルを .</description>
    </item>
    
    <item>
      <title>ペアプロをやってみよう</title>
      <link>http://tkengo.github.io/blog/2012/10/30/lets-pair-programing/</link>
      <pubDate>Tue, 30 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2012/10/30/lets-pair-programing/</guid>
      <description>ペアプロですよ。ペアプロ。ペアプロっていうとあれですよ、2人1組みでペアになって1人がコーディング、1人が観察。 観察してる人はコーディングしてる人に対してあーだこーだ言って、より良いコードを作り上げていきます。
ペアプロについてのメリット/デメリットは各所でいろいろと説明されてるのでここでは省くとして、 僕は今、実際に業務でペアプロをやってるのでせっかくなのでそのやり方を紹介します。
準備するもの  tmux vim(ターミナル上で動くテキストエディタであれば何でも&amp;hellip;)  えっ、これだけ？んーこれだけです&amp;hellip;
ペアプロのやり方としては、1つの画面と1つのキーボードに対して2人が張り付くという形式がよくあるかと思いますが、 僕らはtmuxのセッション共有を利用してペアプロしてます。
tmuxを使って画面を共有する ボブとアリスで話を進めます。ボブがコーダーでアリスがナビゲーターとしましょう。
ボブの端末でtmux用ユーザーを作っておく
[bob@bobs_pc] $ adduser tmux [bob@bobs_pc] $ passwd tmux  ボブの端末でセッションファイルを指定してtmuxを起動する。 セッションファイルはパーミッションを 777 にしておきます。
[bob@bobs_pc] $ tmux -S /tmp/tmux.shared_sock [bob@bobs_pc] $ chmod 777 /tmp/tmux.shared_sock  アリスはボブの端末にsshでログインする
[alice@alices_pc] $ ssh tmux@bobの端末  アリスはボブの端末でセッションファイルを指定してtmuxを起動する
[tmux@bobs_pc] $ tmux -S /tmp/tmux.shared_sock attach  これでボブとアリスはキーボードとディスプレイは自分の目の前にあるものを使うことができ、 かつ画面はボブの画面を共有することができました！ペアプロをはじめます！
ペアプロをやるにあたって 僕らがペアプロをやる時はこんなことに注意したりしてます。
コーダーの人は  自分の頭の中を口に出しながらコーディングする 一人でもくもくと先に進まない  これを意識してやります。せっかくペアプロしてても、しゃべらずに黙ってもくもくと先に進めるのはもったいないです。 「どこどこをどういう風に実装していこうとしているのか」はコーダーの人が黙ってては、ナビゲータの人に全然伝わりません。 ナビゲータの人もぼけーっと画面を見つめるだけになってしまって、本当のメリットが見いだせない。。。
ナビゲータの人は  恐れずにヤジをいれる たまにキーボード奪って「こうやった方がいいよ！」ってするｗ  まぁ程度によりますが、ちゃんとツッコミいれましょう！見てるだけじゃ意味ないですもんね。</description>
    </item>
    
    <item>
      <title>RailsプロジェクトでJenkinsを使ってCIしてみる</title>
      <link>http://tkengo.github.io/blog/2012/10/04/rails-jenkins-ci/</link>
      <pubDate>Thu, 04 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2012/10/04/rails-jenkins-ci/</guid>
      <description>会社のプロジェクトでRuby on Railsを使っていて、Jenkinsを使ってCI環境を整えたくって ずっと試行錯誤していたのですが、最近ようやく出来上がったのでその全貌を明らかにします！
ちなみに全部Linuxでの話なので、Windowsの人は残念ながら役に立ちません&amp;hellip;
目標 今回Jenkinsを使って以下のようなことがやりたかった。
 githubにあるリポジトリのRSpecのテストを自動的に実行したい Capybaraを使ったテストもやってるので、ブラウザが起動する環境で自動テストを実行したい。 これは別途デスクトップ環境(今回の場合はUbuntuデスクトップ)を準備してそこでテストさせたい。 コードカバレッジを出力してるのでJenkinsから見れるようにしたい テストケース一覧もJenkinsから見れるようにしたい  この目標に向かっていろいろと設定をしていきます。
Javaのインストール Jenkinsを動作させるにはJavaが必要ですのでJDKをインストールします。 この記事執筆時点ではこちらから 最新のJDKがダウンロードできます。JDKのダウンロードボタンをクリックして Accept License Agreement の ラジオボタンにチェックを入れてからLinux用のJDKをダウンロードしてインストールします。
$ cd /usr/local/src $ wget http://download.oracle.com/otn-pub/java/jdk/7u7-b10/jdk-7u7-linux-x64.rpm $ rpm -ivh jdk-7u7-linux-x64.rpm  これでインストール完了。
$ java -version  と打って、Javaのバージョン番号が表示されれば成功。
Jenkinsのインストール yumで簡単にインストールできます。以下rootユーザーで作業します。
$ wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo $ rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key $ yum install jenkins  これだけです。そして以下のコマンドで起動できます。
$ /etc/init.d/jenkins start  この状態でhttp://hostname:8080/にアクセスするとJenkinsの画面が開きます。
プラグインのインストール Jenkinsには豊富なプラグインが存在します。 今回の目標としていることも、プラグインなしには実現出来ないので、まず最初にプラグインをインストールします。 Jenkinsの管理 ＞ プラグインの管理 とたどっていき、 利用可能 のタブをクリックします。 今回使うプラグインは以下の3つです。</description>
    </item>
    
    <item>
      <title>Asset Pipeline について勉強した</title>
      <link>http://tkengo.github.io/blog/2012/09/08/rails-asset-pipeline/</link>
      <pubDate>Sat, 08 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2012/09/08/rails-asset-pipeline/</guid>
      <description>ペパボは今、開発言語をRubyに切り替え始めています。
僕も今、Ruby on Railsを使って開発をしているので、本格的にRuby周りの勉強をし始めているのですが、未だにAsset Pipelineがよくわかってないので、この機会にドキュメントを読んできちんと調べてみました。
参考にしたのはここ。 http://guides.rubyonrails.org/asset_pipeline.html
やっぱり公式のドキュメントが一番わかりやすいかな？自分自身がちゃんと覚えるように読みながらまとめてみました。
Asset Pipelineってなに？ Rails3.1より実装された仕組みで、大きくわけて以下の3つの機能があるようです。
 CSSやJavaScriptなどの、いわゆるasset(資源)と呼ばれるファイルを1つにまとめてくれます。普通cssやjsなどのファイルは、開発しやすいように機能毎や画面毎に分けて作業すると思いますが、これはブラウザにとってはファイルの分だけサーバーへのリクエストが発生して効率が悪いです。ブラウザにとっては、ファイルが1つにまとまっていたほうが効率がいいのです。 まとめられたファイルは、同時にミニファイ(圧縮)されます。スペースやタブ、改行などを取り除き、コンパクトに圧縮してくれます。jsファイルに限っては、それだけではなくもう少し複雑なアルゴリズムで圧縮されるようです。 CSSはSASS、JavaScriptはCoffeeScript、を使って記述できます。もちろんSASSやCoffeeScriptを使わずにそのままCSSやJavaScriptで記述することもできます。また、ERB(Embedded Ruby)でも記述できます。  こういった機能がそなわっています。
コードの結合 - マニフェストファイル まず1つ目の機能の資源の結合について、これはSprocketというgemがあって、そいつがいろいろとよしなにしてくれるわけですが、そのためにマニフェストファイルというものを使います。これは、どのファイルを読みこんで、1ファイルにまとめればいいのかをSprocketが把握するためのものです。Railsでアプリケーションを新しく作った時、app/assets/javascripts/application.jsというファイルがデフォルトであると思います。このファイルを開いて中身を見てみると
//= require jquery //= require jquery_ujs //= require_tree .  といった行があります。//=で始まる行はSprocketのディレクティブで、この例では、requireとrequire_treeというコマンドが使われています。名前でなんとなくわかると思いますが、requireは1つのファイルを、require_treeは再帰的にディレクトリ以下の全ファイルを、読み込もうとします。この場合、jquery.js、jquery_ujs.js、それとapp/assets/javascripts/以下にあるすべての.jsファイルを1つのファイルにまとめてくれます。
同じようにapp/assets/stylesheets/applications.cssというファイルもデフォルトであると思いますので、このファイルの中身を覗いてみると
/** * * *= require_self *= require_tree . */  こういう行があるのがわかります。cssの場合は*=で始まるんですね。
それから、各ディレクトリのindexという名前のファイルもマニフェストファイルとして読み込んでくれるようです。 例えば、lib/assets/library_name/というディレクトリに何かしらのJavaScriptのライブラリがあったとすると、 lib/assets/library_name/index.jsというファイルに
//= require_tree .  と書いておけば、そのライブラリに関するファイルを1ファイルにまとめてくれるとのことです。
コードの圧縮 - コンプレッサー 2つ目の機能でコードのミニファイをあげましたが、これは特になにも指定しなくても勝手にやってくれます。ただ、デフォルトの圧縮以外にもCSSやJavaScriptの圧縮機構を自分で指定することができます。app/config/application.rbで
config.assets.css_compressor = :yui  と指定すると、YUI CSS compressorのアルゴリズムを使ってCSSを圧縮します。JavaScriptの場合は
config.assets.js_compressor = :uglifier  と指定すると、uglifierを使ってJavaScriptを圧縮します。また、外部ライブラリではなく自分が開発した独自の圧縮アルゴリズムを指定することもできるみたいです。compressというメソッドを持つクラスを定義して、そのインスタンスを指定します。</description>
    </item>
    
    <item>
      <title>jQuery Mobileでscriptタグが2回実行されてハマった</title>
      <link>http://tkengo.github.io/blog/2012/08/30/jquery-mobile-js-execute/</link>
      <pubDate>Thu, 30 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2012/08/30/jquery-mobile-js-execute/</guid>
      <description>モバイルフレームワークのjQuery mobileを使ってると、scriptタグに書いたJavaScriptがなぜか2回実行されてしまって、かなりはまりました。
こんなコードで
&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; : : &amp;lt;script src=&amp;quot;jquery-mobile.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; alert(&#39;hoge&#39;); &amp;lt;/script&amp;gt;  これだと、最後の行のscriptタグが2回実行されて、hogeというアラートが2回表示されてしまいました。これが何故2回実行されてしまうのかが、まったくわからずに半日くらいはまってましたが、リファレンス読んだら解決しました。
ドキュメント読め俺&amp;hellip;
で、解決策はというと
&amp;lt;body&amp;gt; &amp;lt;div data-role=&amp;quot;page&amp;quot;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt;  という風に、 data-role 属性に page という値を指定してあげると解決しました。 jQuery mobileはページ間移動にはAjaxを使い、そのレスポンスをbodyに挿入して現在のページと差し替えます。 Ajaxのレスポンスの中に data-role=&amp;quot;page&amp;quot; という属性があると、そのタグに囲まれた部分だけを挿入する、という仕組みのようです。
リファレンスを読む限りはこの属性値は通常、ページ毎に配置するように書かれています。
参考 jQuery mobile リファレンス</description>
    </item>
    
    <item>
      <title>日本人ならではのCakePHPへの貢献(CakePHP Advent Calendar 2011)</title>
      <link>http://tkengo.github.io/blog/2011/12/12/cakephp-advent-calender/</link>
      <pubDate>Mon, 12 Dec 2011 00:00:00 +0000</pubDate>
      
      <guid>http://tkengo.github.io/blog/2011/12/12/cakephp-advent-calender/</guid>
      <description>この記事はCakePHP Advent Calendar 2011に参加しています。13日目です。
前日は@slumbers99さんのPrefixルーティングとthemeのススメでした。 3キャリア対応サイトをCakePHPで作った時に利用されたというPrefixルーティングとテーマのお話ですね。 テーマは僕も使ったことがありますが、とても便利な機能だと思います！便利なものはどんどん使って楽していきたいですね。
まえおき みなさん素晴らしい記事を次々と公開されていく中、なにを書こうかとずっと迷っていましたが、 今回はタイトルの通りCakePHPへの貢献について少し書きたいと思います。自分自身の経験によるものです。
CakePHPへの貢献しているでしょうか？僕は全然やってません。 やってませんが、CakePHPが1.1の頃からずっと使っていて、なにかしら役に立ちたいなぁと思って今まで過ごしてきました。 でも、ド田舎に住む1利用者に過ぎない僕みたいな技術者が、何が出来るだろうとも感じていました。 そういう人って実際に多いんじゃないかな。 CakePHP利用者で僕が昔から知ってる人達の日記を読みながら「勉強会とか楽しそうだな」と羨ましく思ったものです。
でも、最近ちょっと考えが変わってきました。 自分が出来ること をすればいいんです。 コアデベロッパでもないのに開発に携わろうとしたり、無理に遠くでやってるイベントに参加しようとしたり、そういうことがダメでした。 大事なので2回言いますが、 自分が出来ること をすればいいんです。僕の場合は2つありました。
 ブログでアウトプットする CakePHPのドキュメントの翻訳  です。ブログでのアウトプットの重要性は、もう既に多くの人が声高に叫んでいます。 アウトプットを頑張るようにしました。
それから、僕は英語が好きです。英語力はある方とはいえないけど、読み書きはある程度できます。 なので、それをCakePHPと結びつけて役立てるにはどうしたらいいのか、っていうことを考えた時にドキュメントの翻訳にたどり着きました。
さて今回はこのドキュメントの翻訳について少し書いていきたいと思います。
最初にやること これがCakePHP2.0のドキュメントです。Cookbook。 既にいくらか日本語化されている部分もあります。 翻訳に参加したければまずはCakePHPドキュメントチームに挨拶ぐらいしておきましょう （しなくてもいいかもしれませんが、僕はメールを送りました）。 一応ここにも「翻訳に参加する場合はメールください」とありますし。 簡単な自己紹介と翻訳に参加したい旨のメールです。こんな感じ
Dear CakePHP docs team. My name is Kengo Tateishi. I&#39;m a programmer in Japan. I have developed a web application with CakePHP since its version was 1.1.x. I love CakePHP. I would like to participate in translating the CakePHP 2.</description>
    </item>
    
  </channel>
</rss>